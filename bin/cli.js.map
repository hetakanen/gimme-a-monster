{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/commander/index.js","node_modules/commander/lib/argument.js","node_modules/commander/lib/command.js","node_modules/commander/lib/error.js","node_modules/commander/lib/help.js","node_modules/commander/lib/option.js","node_modules/commander/lib/suggestSimilar.js","node_modules/events/events.js","node_modules/is-buffer/index.js","node_modules/path-browserify/index.js","node_modules/process/browser.js","src/cli.ts","src/data/color-options.json","src/data/eye-options.json","src/data/monster-options.json","src/data/mood-options.json","src/data/shape-options.json","src/data/size-options.json","src/index.ts","src/monsterGenerator.ts","src/randomValueGenerator.ts","src/stringFormatter.ts"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","Argument","Command","CommanderError","InvalidArgumentError","Help","Option","program","InvalidOptionArgumentError","constructor","name","description","this","variadic","parseArg","undefined","defaultValue","defaultValueDescription","argChoices","required","_name","slice","_concatValue","value","previous","Array","isArray","concat","default","argParser","fn","choices","values","arg","includes","join","argRequired","argOptional","humanReadableArgName","nameOutput","EventEmitter","childProcess","path","fs","splitOptionFlags","suggestSimilar","super","commands","options","parent","_allowUnknownOption","_allowExcessArguments","_args","args","rawArgs","processedArgs","_scriptPath","_optionValues","_optionValueSources","_storeOptionsAsProperties","_actionHandler","_executableHandler","_executableFile","_defaultCommandName","_exitCallback","_aliases","_combineFlagAndOptionalValue","_description","_argsDescription","_enablePositionalOptions","_passThroughOptions","_lifeCycleHooks","_showHelpAfterError","_showSuggestionAfterError","_outputConfiguration","writeOut","process","stdout","write","str","writeErr","stderr","getOutHelpWidth","isTTY","columns","getErrHelpWidth","outputError","_hidden","_hasHelpOption","_helpFlags","_helpDescription","_helpShortFlag","_helpLongFlag","_addImplicitHelpCommand","_helpCommandName","_helpCommandnameAndArgs","_helpCommandDescription","_helpConfiguration","copyInheritedSettings","sourceCommand","command","nameAndArgs","actionOptsOrExecDesc","execOpts","let","desc","opts","match","cmd","createCommand","isDefault","noHelp","hidden","executableFile","arguments","push","createHelp","Object","assign","configureHelp","configuration","configureOutput","showHelpAfterError","displayHelp","showSuggestionAfterError","displaySuggestion","addCommand","checkExplicitNames","commandArray","forEach","createArgument","argument","addArgument","names","split","detail","previousArgument","addHelpCommand","enableOrNameAndArgs","_hasImplicitHelpCommand","_findCommand","hook","event","listener","allowedValues","exitOverride","err","_exit","exitCode","message","exit","action","expectedArgsCount","actionArgs","apply","createOption","flags","addOption","option","positiveLongFlag","oname","attributeName","negate","optional","long","replace","_findOption","getOptionValue","setOptionValueWithSource","handleOptionValue","val","invalidValueMessage","valueSource","oldValue","_displayError","on","envVar","_optionEx","config","makeOptionMandatory","mandatory","RegExp","regex","def","m","exec","requiredOption","combineFlagAndOptionalValue","combine","allowUnknownOption","allowUnknown","allowExcessArguments","allowExcess","enablePositionalOptions","positional","passThroughOptions","passThrough","storeOptionsAsProperties","storeAsProperties","key","setOptionValue","source","getOptionValueSource","_prepareUserArgs","argv","parseOptions","versions","electron","from","userArgs","defaultApp","main","filename","basename","extname","parse","_parseCommand","parseAsync","_executeSubCommand","subcommand","sourceExt","_checkForMissingMandatoryOptions","scriptPath","baseDir","resolvedLink","realpathSync","dirname","bin","localBin","existsSync","ext","launchWithNode","proc","platform","unshift","incrementNodeInspectorPort","execArgv","spawn","stdio","execPath","signal","killed","kill","exitCallback","bind","executableMissing","wrappedError","nestedError","runningCommand","_dispatchSubcommand","commandName","operands","unknown","subCommand","help","error","_checkNumberOfArguments","missingArgument","_excessArguments","_processArguments","myParseArg","parsedValue","declaredArg","index","reduce","processed","v","_chainOrCall","promise","then","_chainOrCallHooks","result","hooks","getCommandAndParents","reverse","filter","hookedCommand","callback","hookDetail","parsed","_parseOptionsEnv","outputHelpIfRequested","actionResult","checkForUnknownOptions","unknownOption","commandEvent","emit","listenerCount","unknownCommand","find","is","anOption","missingMandatoryOptionValue","dest","maybeOption","activeVariadicOption","shift","optionMissingArgument","test","indexOf","len","_versionOptionName","_version","outputHelp","optionKey","env","flag","suggestion","startsWith","candidateFlags","moreFlags","visibleOptions","map","receivedArgs","expected","s","unknownName","candidateNames","visibleCommands","alias","version","versionOption","argsDescription","aliases","usage","_usage","helpInformation","contextOptions","helper","helpWidth","formatHelp","_getHelpContext","context","deprecatedCallback","Buffer","isBuffer","helpOption","helpFlags","shortFlag","longFlag","addHelpText","position","text","helpStr","debugOption","debugHost","debugPort","parseInt","startCommand","captureStackTrace","sortSubcommands","sortOptions","helpName","helpArgs","helpCommand","sort","b","localeCompare","showShortHelpFlag","showLongHelpFlag","getSortKey","short","visibleArguments","subcommandTerm","optionTerm","argumentTerm","longestSubcommandTermLength","max","Math","longestOptionTermLength","longestArgumentTermLength","commandUsage","cmdName","parentCmdNames","parentCmd","commandDescription","subcommandDescription","optionDescription","extraInfo","JSON","stringify","choice","argumentDescription","extraDescripton","termWidth","padWidth","formatItem","term","fullText","padEnd","wrap","formatList","textArray","repeat","output","argumentList","optionList","commandList","width","indent","minColumnWidth","columnWidth","leadingStr","substr","columnText","indentString","lines","line","trimRight","flagParts","optionFlags","hideHelp","hide","word","toUpperCase","maxDistance","candidates","Set","searchingOptions","candidate","similar","bestDistance","distance","abs","d","j","cost","min","editDistance","R","Reflect","ReflectApply","target","receiver","Function","prototype","ReflectOwnKeys","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","NumberIsNaN","Number","isNaN","init","once","emitter","Promise","resolve","reject","errorListener","removeListener","resolver","handler","eventTargetAgnosticAddListener","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","TypeError","_getMaxListeners","that","_addListener","type","prepend","events","existing","create","newListener","warned","w","String","count","warning","console","warn","_onceWrap","state","fired","wrapFn","wrapped","_listeners","unwrap","evlistener","arr","ret","unwrapListeners","arrayClone","copy","addEventListener","wrapListener","removeEventListener","defineProperty","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","er","doError","listeners","addListener","prependListener","prependOnceListener","off","list","originalListener","pop","spliceOne","removeAllListeners","keys","rawListeners","eventNames","obj","readFloatLE","_isBuffer","assertPath","normalizeStringPosix","allowAboveRoot","res","lastSegmentLength","lastSlash","dots","charCodeAt","lastSlashIndex","lastIndexOf","posix","cwd","resolvedPath","resolvedAbsolute","normalize","isAbsolute","trailingSeparator","joined","relative","to","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","hasRoot","end","matchedSlash","start","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","format","pathObject","sep","dir","root","base","delimiter","win32","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","array","noop","nextTick","title","browser","binding","chdir","umask","commander_1","index_1","complexity","log","casing","generateMonster","monsterGenerator_1","generate","color_options_json_1","__importDefault","size_options_json_1","shape_options_json_1","mood_options_json_1","eye_options_json_1","monster_options_json_1","randomValueGenerator_1","stringFormatter_1","stringified","properties","size","getRandomValue","mood","eyes","shape","color","toString","prop","props","floor","random","getRandomNumber","charAt","string","toLocaleLowerCase"],"mappings":"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","file":"cli.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","const { Argument } = require('./lib/argument.js');\nconst { Command } = require('./lib/command.js');\nconst { CommanderError, InvalidArgumentError } = require('./lib/error.js');\nconst { Help } = require('./lib/help.js');\nconst { Option } = require('./lib/option.js');\n\n// @ts-check\n\n/**\n * Expose the root command.\n */\n\nexports = module.exports = new Command();\nexports.program = exports; // More explicit access to global command.\n// Implicit export of createArgument, createCommand, and createOption.\n\n/**\n * Expose classes\n */\n\nexports.Argument = Argument;\nexports.Command = Command;\nexports.CommanderError = CommanderError;\nexports.Help = Help;\nexports.InvalidArgumentError = InvalidArgumentError;\nexports.InvalidOptionArgumentError = InvalidArgumentError; // Deprecated\nexports.Option = Option;\n","const { InvalidArgumentError } = require('./error.js');\n\n// @ts-check\n\nclass Argument {\n  /**\n   * Initialize a new command argument with the given name and description.\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   */\n\n  constructor(name, description) {\n    this.description = description || '';\n    this.variadic = false;\n    this.parseArg = undefined;\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.argChoices = undefined;\n\n    switch (name[0]) {\n      case '<': // e.g. <required>\n        this.required = true;\n        this._name = name.slice(1, -1);\n        break;\n      case '[': // e.g. [optional]\n        this.required = false;\n        this._name = name.slice(1, -1);\n        break;\n      default:\n        this.required = true;\n        this._name = name;\n        break;\n    }\n\n    if (this._name.length > 3 && this._name.slice(-3) === '...') {\n      this.variadic = true;\n      this._name = this._name.slice(0, -3);\n    }\n  }\n\n  /**\n   * Return argument name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    return this._name;\n  };\n\n  /**\n   * @api private\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {any} value\n   * @param {string} [description]\n   * @return {Argument}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  };\n\n  /**\n   * Set the custom handler for processing CLI command arguments into argument values.\n   *\n   * @param {Function} [fn]\n   * @return {Argument}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  };\n\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Argument}\n   */\n\n  choices(values) {\n    this.argChoices = values;\n    this.parseArg = (arg, previous) => {\n      if (!values.includes(arg)) {\n        throw new InvalidArgumentError(`Allowed choices are ${values.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  };\n\n  /**\n   * Make option-argument required.\n   */\n  argRequired() {\n    this.required = true;\n    return this;\n  }\n\n  /**\n   * Make option-argument optional.\n   */\n  argOptional() {\n    this.required = false;\n    return this;\n  }\n}\n\n/**\n * Takes an argument and returns its human readable equivalent for help usage.\n *\n * @param {Argument} arg\n * @return {string}\n * @api private\n */\n\nfunction humanReadableArgName(arg) {\n  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');\n\n  return arg.required\n    ? '<' + nameOutput + '>'\n    : '[' + nameOutput + ']';\n}\n\nexports.Argument = Argument;\nexports.humanReadableArgName = humanReadableArgName;\n","const EventEmitter = require('events').EventEmitter;\nconst childProcess = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\n\nconst { Argument, humanReadableArgName } = require('./argument.js');\nconst { CommanderError } = require('./error.js');\nconst { Help } = require('./help.js');\nconst { Option, splitOptionFlags } = require('./option.js');\nconst { suggestSimilar } = require('./suggestSimilar');\n\n// @ts-check\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n\n  constructor(name) {\n    super();\n    /** @type {Command[]} */\n    this.commands = [];\n    /** @type {Option[]} */\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = true;\n    /** @type {Argument[]} */\n    this._args = [];\n    /** @type {string[]} */\n    this.args = []; // cli args with options removed\n    this.rawArgs = [];\n    this.processedArgs = []; // like .args but after custom processing and collecting variadic\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._optionValueSources = {}; // default < config < env < cli\n    this._storeOptionsAsProperties = false;\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._argsDescription = undefined; // legacy\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false;\n    this._lifeCycleHooks = {}; // a hash of arrays\n    /** @type {boolean | string} */\n    this._showHelpAfterError = false;\n    this._showSuggestionAfterError = false;\n\n    // see .configureOutput() for docs\n    this._outputConfiguration = {\n      writeOut: (str) => process.stdout.write(str),\n      writeErr: (str) => process.stderr.write(str),\n      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,\n      outputError: (str, write) => write(str)\n    };\n\n    this._hidden = false;\n    this._hasHelpOption = true;\n    this._helpFlags = '-h, --help';\n    this._helpDescription = 'display help for command';\n    this._helpShortFlag = '-h';\n    this._helpLongFlag = '--help';\n    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false\n    this._helpCommandName = 'help';\n    this._helpCommandnameAndArgs = 'help [command]';\n    this._helpCommandDescription = 'display help for command';\n    this._helpConfiguration = {};\n  }\n\n  /**\n   * Copy settings that are useful to have in common across root command and subcommands.\n   *\n   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)\n   *\n   * @param {Command} sourceCommand\n   * @return {Command} returns `this` for executable command\n   */\n  copyInheritedSettings(sourceCommand) {\n    this._outputConfiguration = sourceCommand._outputConfiguration;\n    this._hasHelpOption = sourceCommand._hasHelpOption;\n    this._helpFlags = sourceCommand._helpFlags;\n    this._helpDescription = sourceCommand._helpDescription;\n    this._helpShortFlag = sourceCommand._helpShortFlag;\n    this._helpLongFlag = sourceCommand._helpLongFlag;\n    this._helpCommandName = sourceCommand._helpCommandName;\n    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;\n    this._helpCommandDescription = sourceCommand._helpCommandDescription;\n    this._helpConfiguration = sourceCommand._helpConfiguration;\n    this._exitCallback = sourceCommand._exitCallback;\n    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;\n    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;\n    this._allowExcessArguments = sourceCommand._allowExcessArguments;\n    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;\n    this._showHelpAfterError = sourceCommand._showHelpAfterError;\n    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;\n\n    return this;\n  }\n\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * @example\n   * // Command implemented using action handler (description is supplied separately to `.command`)\n   * program\n   *   .command('clone <source> [destination]')\n   *   .description('clone a repository into a newly created directory')\n   *   .action((source, destination) => {\n   *     console.log('clone command called');\n   *   });\n   *\n   * // Command implemented using separate executable file (description is second parameter to `.command`)\n   * program\n   *   .command('start <service>', 'start named service')\n   *   .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {Object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n    opts = opts || {};\n    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);\n\n    const cmd = this.createCommand(name);\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n    if (args) cmd.arguments(args);\n    this.commands.push(cmd);\n    cmd.parent = this;\n    cmd.copyInheritedSettings(this);\n\n    if (desc) return this;\n    return cmd;\n  };\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n\n  createCommand(name) {\n    return new Command(name);\n  };\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  };\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n\n    this._helpConfiguration = configuration;\n    return this;\n  }\n\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *     // functions to change where being written, stdout and stderr\n   *     writeOut(str)\n   *     writeErr(str)\n   *     // matching functions to specify width for wrapping help\n   *     getOutHelpWidth()\n   *     getErrHelpWidth()\n   *     // functions based on what is being written out\n   *     outputError(str, write) // used for displaying errors, and not used for displaying help\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n\n    Object.assign(this._outputConfiguration, configuration);\n    return this;\n  }\n\n  /**\n   * Display the help or a custom message after an error occurs.\n   *\n   * @param {boolean|string} [displayHelp]\n   * @return {Command} `this` command for chaining\n   */\n  showHelpAfterError(displayHelp = true) {\n    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;\n    this._showHelpAfterError = displayHelp;\n    return this;\n  }\n\n  /**\n   * Display suggestion of similar commands for unknown commands, or options for unknown options.\n   *\n   * @param {boolean} [displaySuggestion]\n   * @return {Command} `this` command for chaining\n   */\n  showSuggestionAfterError(displaySuggestion = true) {\n    this._showSuggestionAfterError = !!displaySuggestion;\n    return this;\n  }\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {Object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) throw new Error('Command passed to .addCommand() must have a name');\n\n    // To keep things simple, block automatic name generation for deeply nested executables.\n    // Fail fast and detect when adding rather than later when parsing.\n    function checkExplicitNames(commandArray) {\n      commandArray.forEach((cmd) => {\n        if (cmd._executableHandler && !cmd._executableFile) {\n          throw new Error(`Must specify executableFile for deeply nested executable: ${cmd.name()}`);\n        }\n        checkExplicitNames(cmd.commands);\n      });\n    }\n    checkExplicitNames(cmd.commands);\n\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this.commands.push(cmd);\n    cmd.parent = this;\n    return this;\n  };\n\n  /**\n   * Factory routine to create a new unattached argument.\n   *\n   * See .argument() for creating an attached argument, which uses this routine to\n   * create the argument. You can override createArgument to return a custom argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @return {Argument} new argument\n   */\n\n  createArgument(name, description) {\n    return new Argument(name, description);\n  };\n\n  /**\n   * Define argument syntax for command.\n   *\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @example\n   * program.argument('<input-file>');\n   * program.argument('[output-file]');\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom argument processing function\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n  argument(name, description, fn, defaultValue) {\n    const argument = this.createArgument(name, description);\n    if (typeof fn === 'function') {\n      argument.default(defaultValue).argParser(fn);\n    } else {\n      argument.default(fn);\n    }\n    this.addArgument(argument);\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding multiple at once (without descriptions).\n   *\n   * See also .argument().\n   *\n   * @example\n   * program.arguments('<cmd> [env]');\n   *\n   * @param {string} names\n   * @return {Command} `this` command for chaining\n   */\n\n  arguments(names) {\n    names.split(/ +/).forEach((detail) => {\n      this.argument(detail);\n    });\n    return this;\n  };\n\n  /**\n   * Define argument syntax for command, adding a prepared argument.\n   *\n   * @param {Argument} argument\n   * @return {Command} `this` command for chaining\n   */\n  addArgument(argument) {\n    const previousArgument = this._args.slice(-1)[0];\n    if (previousArgument && previousArgument.variadic) {\n      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);\n    }\n    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {\n      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);\n    }\n    this._args.push(argument);\n    return this;\n  }\n\n  /**\n   * Override default decision whether to add implicit help command.\n   *\n   *    addHelpCommand() // force on\n   *    addHelpCommand(false); // force off\n   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details\n   *\n   * @return {Command} `this` command for chaining\n   */\n\n  addHelpCommand(enableOrNameAndArgs, description) {\n    if (enableOrNameAndArgs === false) {\n      this._addImplicitHelpCommand = false;\n    } else {\n      this._addImplicitHelpCommand = true;\n      if (typeof enableOrNameAndArgs === 'string') {\n        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];\n        this._helpCommandnameAndArgs = enableOrNameAndArgs;\n      }\n      this._helpCommandDescription = description || this._helpCommandDescription;\n    }\n    return this;\n  };\n\n  /**\n   * @return {boolean}\n   * @api private\n   */\n\n  _hasImplicitHelpCommand() {\n    if (this._addImplicitHelpCommand === undefined) {\n      return this.commands.length && !this._actionHandler && !this._findCommand('help');\n    }\n    return this._addImplicitHelpCommand;\n  };\n\n  /**\n   * Add hook for life cycle event.\n   *\n   * @param {string} event\n   * @param {Function} listener\n   * @return {Command} `this` command for chaining\n   */\n\n  hook(event, listener) {\n    const allowedValues = ['preAction', 'postAction'];\n    if (!allowedValues.includes(event)) {\n      throw new Error(`Unexpected value for event passed to hook : '${event}'.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    if (this._lifeCycleHooks[event]) {\n      this._lifeCycleHooks[event].push(listener);\n    } else {\n      this._lifeCycleHooks[event] = [listener];\n    }\n    return this;\n  }\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = (err) => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {\n          // Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n    return this;\n  };\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @api private\n   */\n\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message));\n      // Expecting this line is not reached.\n    }\n    process.exit(exitCode);\n  };\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * @example\n   * program\n   *   .command('serve')\n   *   .description('start service')\n   *   .action(function() {\n   *      // do work here\n   *   });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n\n  action(fn) {\n    const listener = (args) => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this._args.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n      actionArgs.push(this);\n\n      return fn.apply(this, actionArgs);\n    };\n    this._actionHandler = listener;\n    return this;\n  };\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n\n  createOption(flags, description) {\n    return new Option(flags, description);\n  };\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    const oname = option.name();\n    const name = option.attributeName();\n\n    let defaultValue = option.defaultValue;\n\n    // preassign default value for --no-*, [optional], <required>, or plain flag if boolean value\n    if (option.negate || option.optional || option.required || typeof defaultValue === 'boolean') {\n      // when --no-foo we make sure default is true, unless a --foo option is already defined\n      if (option.negate) {\n        const positiveLongFlag = option.long.replace(/^--no-/, '--');\n        defaultValue = this._findOption(positiveLongFlag) ? this.getOptionValue(name) : true;\n      }\n      // preassign only if we have a default\n      if (defaultValue !== undefined) {\n        this.setOptionValueWithSource(name, defaultValue, 'default');\n      }\n    }\n\n    // register the option\n    this.options.push(option);\n\n    // handler for cli and env supplied values\n    const handleOptionValue = (val, invalidValueMessage, valueSource) => {\n      // Note: using closure to access lots of lexical scoped variables.\n      const oldValue = this.getOptionValue(name);\n\n      // custom processing\n      if (val !== null && option.parseArg) {\n        try {\n          val = option.parseArg(val, oldValue === undefined ? defaultValue : oldValue);\n        } catch (err) {\n          if (err.code === 'commander.invalidArgument') {\n            const message = `${invalidValueMessage} ${err.message}`;\n            this._displayError(err.exitCode, err.code, message);\n          }\n          throw err;\n        }\n      } else if (val !== null && option.variadic) {\n        val = option._concatValue(val, oldValue);\n      }\n\n      // unassigned or boolean value\n      if (typeof oldValue === 'boolean' || typeof oldValue === 'undefined') {\n        // if no value, negate false, and we have a default, then use it!\n        if (val == null) {\n          this.setOptionValueWithSource(name, option.negate ? false : defaultValue || true, valueSource);\n        } else {\n          this.setOptionValueWithSource(name, val, valueSource);\n        }\n      } else if (val !== null) {\n        // reassign\n        this.setOptionValueWithSource(name, option.negate ? false : val, valueSource);\n      }\n    };\n\n    this.on('option:' + oname, (val) => {\n      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;\n      handleOptionValue(val, invalidValueMessage, 'cli');\n    });\n\n    if (option.envVar) {\n      this.on('optionEnv:' + oname, (val) => {\n        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;\n        handleOptionValue(val, invalidValueMessage, 'env');\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @api private\n   */\n  _optionEx(config, flags, description, fn, defaultValue) {\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n\n    return this.addOption(option);\n  }\n\n  /**\n   * Define option with `flags`, `description` and optional\n   * coercion `fn`.\n   *\n   * The `flags` string contains the short and/or long flags,\n   * separated by comma, a pipe or space. The following are all valid\n   * all will output this way when `--help` is used.\n   *\n   *     \"-p, --pepper\"\n   *     \"-p|--pepper\"\n   *     \"-p --pepper\"\n   *\n   * @example\n   * // simple boolean defaulting to undefined\n   * program.option('-p, --pepper', 'add pepper');\n   *\n   * program.pepper\n   * // => undefined\n   *\n   * --pepper\n   * program.pepper\n   * // => true\n   *\n   * // simple boolean defaulting to true (unless non-negated option is also defined)\n   * program.option('-C, --no-cheese', 'remove cheese');\n   *\n   * program.cheese\n   * // => true\n   *\n   * --no-cheese\n   * program.cheese\n   * // => false\n   *\n   * // required argument\n   * program.option('-C, --chdir <path>', 'change the working directory');\n   *\n   * --chdir /tmp\n   * program.chdir\n   * // => \"/tmp\"\n   *\n   * // optional argument\n   * program.option('-c, --cheese [type]', 'add cheese [marble]');\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  option(flags, description, fn, defaultValue) {\n    return this._optionEx({}, flags, description, fn, defaultValue);\n  };\n\n  /**\n  * Add a required option which must have a value after parsing. This usually means\n  * the option must be specified on the command line. (Otherwise the same as .option().)\n  *\n  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n  *\n  * @param {string} flags\n  * @param {string} [description]\n  * @param {Function|*} [fn] - custom option processing function or default value\n  * @param {*} [defaultValue]\n  * @return {Command} `this` command for chaining\n  */\n\n  requiredOption(flags, description, fn, defaultValue) {\n    return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);\n  };\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * @example\n   * // for `.option('-f,--flag [value]'):\n   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.\n   */\n  combineFlagAndOptionalValue(combine = true) {\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  };\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown\n   * for unknown options.\n   */\n  allowUnknownOption(allowUnknown = true) {\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  };\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown\n   * for excess arguments.\n   */\n  allowExcessArguments(allowExcess = true) {\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  };\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {Boolean} [positional=true]\n   */\n  enablePositionalOptions(positional = true) {\n    this._enablePositionalOptions = !!positional;\n    return this;\n  };\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {Boolean} [passThrough=true]\n   * for unknown options.\n   */\n  passThroughOptions(passThrough = true) {\n    this._passThroughOptions = !!passThrough;\n    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {\n      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');\n    }\n    return this;\n  };\n\n  /**\n    * Whether to store option values as properties on command object,\n    * or store separately (specify false). In both cases the option values can be accessed using .opts().\n    *\n    * @param {boolean} [storeAsProperties=true]\n    * @return {Command} `this` command for chaining\n    */\n\n  storeOptionsAsProperties(storeAsProperties = true) {\n    this._storeOptionsAsProperties = !!storeAsProperties;\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n    return this;\n  };\n\n  /**\n   * Retrieve option value.\n   *\n   * @param {string} key\n   * @return {Object} value\n   */\n\n  getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n    return this._optionValues[key];\n  };\n\n  /**\n   * Store option value.\n   *\n   * @param {string} key\n   * @param {Object} value\n   * @return {Command} `this` command for chaining\n   */\n\n  setOptionValue(key, value) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n    return this;\n  };\n\n  /**\n   * Store option value and where the value came from.\n    *\n    * @param {string} key\n    * @param {Object} value\n    * @param {string} source - expected values are default/config/env/cli\n    * @return {Command} `this` command for chaining\n    */\n\n  setOptionValueWithSource(key, value, source) {\n    this.setOptionValue(key, value);\n    this._optionValueSources[key] = source;\n    return this;\n  }\n\n  /**\n    * Get source of option value.\n    * Expected values are default | config | env | cli\n    *\n    * @param {string} key\n    * @return {string}\n    */\n\n  getOptionValueSource(key) {\n    return this._optionValueSources[key];\n  };\n\n  /**\n   * Get user arguments implied or explicit arguments.\n   * Side-effects: set _scriptPath if args included application, and use that to set implicit command name.\n   *\n   * @api private\n   */\n\n  _prepareUserArgs(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n    parseOptions = parseOptions || {};\n\n    // Default to using process.argv\n    if (argv === undefined) {\n      argv = process.argv;\n      // @ts-ignore: unknown property\n      if (process.versions && process.versions.electron) {\n        parseOptions.from = 'electron';\n      }\n    }\n    this.rawArgs = argv.slice();\n\n    // make it a little easier for callers by supporting various argv conventions\n    let userArgs;\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n      case 'electron':\n        // @ts-ignore: unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n        break;\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n      default:\n        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);\n    }\n    if (!this._scriptPath && require.main) {\n      this._scriptPath = require.main.filename;\n    }\n\n    // Guess name, used in usage in help.\n    this._name = this._name || (this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath)));\n\n    return userArgs;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * program.parse(process.argv);\n   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n\n  parse(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    this._parseCommand([], userArgs);\n\n    return this;\n  };\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * await program.parseAsync(process.argv);\n   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {Object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n\n  async parseAsync(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    await this._parseCommand([], userArgs);\n\n    return this;\n  };\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @api private\n   */\n\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n    this._checkForMissingMandatoryOptions();\n\n    // Want the entry script as the reference for command name and directory for searching for other files.\n    let scriptPath = this._scriptPath;\n    // Fallback in case not set, due to how Command created or called.\n    if (!scriptPath && require.main) {\n      scriptPath = require.main.filename;\n    }\n\n    let baseDir;\n    try {\n      const resolvedLink = fs.realpathSync(scriptPath);\n      baseDir = path.dirname(resolvedLink);\n    } catch (e) {\n      baseDir = '.'; // dummy, probably not going to find executable!\n    }\n\n    // name of the subcommand, like `pm-install`\n    let bin = path.basename(scriptPath, path.extname(scriptPath)) + '-' + subcommand._name;\n    if (subcommand._executableFile) {\n      bin = subcommand._executableFile;\n    }\n\n    const localBin = path.join(baseDir, bin);\n    if (fs.existsSync(localBin)) {\n      // prefer local `./<bin>` to bin in the $PATH\n      bin = localBin;\n    } else {\n      // Look for source files.\n      sourceExt.forEach((ext) => {\n        if (fs.existsSync(`${localBin}${ext}`)) {\n          bin = `${localBin}${ext}`;\n        }\n      });\n    }\n    launchWithNode = sourceExt.includes(path.extname(bin));\n\n    let proc;\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(bin);\n        // add executable arguments to spawn\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });\n      } else {\n        proc = childProcess.spawn(bin, args, { stdio: 'inherit' });\n      }\n    } else {\n      args.unshift(bin);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });\n    }\n\n    const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n    signals.forEach((signal) => {\n      // @ts-ignore\n      process.on(signal, () => {\n        if (proc.killed === false && proc.exitCode === null) {\n          proc.kill(signal);\n        }\n      });\n    });\n\n    // By default terminate process when spawned process terminates.\n    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!\n    const exitCallback = this._exitCallback;\n    if (!exitCallback) {\n      proc.on('close', process.exit.bind(process));\n    } else {\n      proc.on('close', () => {\n        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));\n      });\n    }\n    proc.on('error', (err) => {\n      // @ts-ignore\n      if (err.code === 'ENOENT') {\n        const executableMissing = `'${bin}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name`;\n        throw new Error(executableMissing);\n      // @ts-ignore\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${bin}' not executable`);\n      }\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    });\n\n    // Store the reference to the child process\n    this.runningCommand = proc;\n  };\n\n  /**\n   * @api private\n   */\n\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n    if (!subCommand) this.help({ error: true });\n\n    if (subCommand._executableHandler) {\n      this._executeSubCommand(subCommand, operands.concat(unknown));\n    } else {\n      return subCommand._parseCommand(operands, unknown);\n    }\n  };\n\n  /**\n   * Check this.args against expected this._args.\n   *\n   * @api private\n   */\n\n  _checkNumberOfArguments() {\n    // too few\n    this._args.forEach((arg, i) => {\n      if (arg.required && this.args[i] == null) {\n        this.missingArgument(arg.name());\n      }\n    });\n    // too many\n    if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {\n      return;\n    }\n    if (this.args.length > this._args.length) {\n      this._excessArguments(this.args);\n    }\n  };\n\n  /**\n   * Process this.args using this._args and save as this.processedArgs!\n   *\n   * @api private\n   */\n\n  _processArguments() {\n    const myParseArg = (argument, value, previous) => {\n      // Extra processing for nice error message on parsing failure.\n      let parsedValue = value;\n      if (value !== null && argument.parseArg) {\n        try {\n          parsedValue = argument.parseArg(value, previous);\n        } catch (err) {\n          if (err.code === 'commander.invalidArgument') {\n            const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;\n            this._displayError(err.exitCode, err.code, message);\n          }\n          throw err;\n        }\n      }\n      return parsedValue;\n    };\n\n    this._checkNumberOfArguments();\n\n    const processedArgs = [];\n    this._args.forEach((declaredArg, index) => {\n      let value = declaredArg.defaultValue;\n      if (declaredArg.variadic) {\n        // Collect together remaining arguments for passing together as an array.\n        if (index < this.args.length) {\n          value = this.args.slice(index);\n          if (declaredArg.parseArg) {\n            value = value.reduce((processed, v) => {\n              return myParseArg(declaredArg, v, processed);\n            }, declaredArg.defaultValue);\n          }\n        } else if (value === undefined) {\n          value = [];\n        }\n      } else if (index < this.args.length) {\n        value = this.args[index];\n        if (declaredArg.parseArg) {\n          value = myParseArg(declaredArg, value, declaredArg.defaultValue);\n        }\n      }\n      processedArgs[index] = value;\n    });\n    this.processedArgs = processedArgs;\n  }\n\n  /**\n   * Once we have a promise we chain, but call synchronously until then.\n   *\n   * @param {Promise|undefined} promise\n   * @param {Function} fn\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCall(promise, fn) {\n    // thenable\n    if (promise && promise.then && typeof promise.then === 'function') {\n      // already have a promise, chain callback\n      return promise.then(() => fn());\n    }\n    // callback might return a promise\n    return fn();\n  }\n\n  /**\n   *\n   * @param {Promise|undefined} promise\n   * @param {string} event\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCallHooks(promise, event) {\n    let result = promise;\n    const hooks = [];\n    getCommandAndParents(this)\n      .reverse()\n      .filter(cmd => cmd._lifeCycleHooks[event] !== undefined)\n      .forEach(hookedCommand => {\n        hookedCommand._lifeCycleHooks[event].forEach((callback) => {\n          hooks.push({ hookedCommand, callback });\n        });\n      });\n    if (event === 'postAction') {\n      hooks.reverse();\n    }\n\n    hooks.forEach((hookDetail) => {\n      result = this._chainOrCall(result, () => {\n        return hookDetail.callback(hookDetail.hookedCommand, this);\n      });\n    });\n    return result;\n  }\n\n  /**\n   * Process arguments in context of this command.\n   * Returns action result, in case it is a promise.\n   *\n   * @api private\n   */\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    }\n    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {\n      if (operands.length === 1) {\n        this.help();\n      }\n      return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);\n    }\n    if (this._defaultCommandName) {\n      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command\n      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);\n    }\n    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {\n      // probably missing subcommand and no handler, user needs help (and exit)\n      this.help({ error: true });\n    }\n\n    outputHelpIfRequested(this, parsed.unknown);\n    this._checkForMissingMandatoryOptions();\n\n    // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n    const checkForUnknownOptions = () => {\n      if (parsed.unknown.length > 0) {\n        this.unknownOption(parsed.unknown[0]);\n      }\n    };\n\n    const commandEvent = `command:${this.name()}`;\n    if (this._actionHandler) {\n      checkForUnknownOptions();\n      this._processArguments();\n\n      let actionResult;\n      actionResult = this._chainOrCallHooks(actionResult, 'preAction');\n      actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));\n      if (this.parent) this.parent.emit(commandEvent, operands, unknown); // legacy\n      actionResult = this._chainOrCallHooks(actionResult, 'postAction');\n      return actionResult;\n    }\n    if (this.parent && this.parent.listenerCount(commandEvent)) {\n      checkForUnknownOptions();\n      this._processArguments();\n      this.parent.emit(commandEvent, operands, unknown); // legacy\n    } else if (operands.length) {\n      if (this._findCommand('*')) { // legacy default command\n        return this._dispatchSubcommand('*', operands, unknown);\n      }\n      if (this.listenerCount('command:*')) {\n        // skip option check, emit event for possible misspelling suggestion\n        this.emit('command:*', operands, unknown);\n      } else if (this.commands.length) {\n        this.unknownCommand();\n      } else {\n        checkForUnknownOptions();\n        this._processArguments();\n      }\n    } else if (this.commands.length) {\n      checkForUnknownOptions();\n      // This command has subcommands and nothing hooked up at this level, so display help (and exit).\n      this.help({ error: true });\n    } else {\n      checkForUnknownOptions();\n      this._processArguments();\n      // fall through for caller to handle after calling .parse()\n    }\n  };\n\n  /**\n   * Find matching command.\n   *\n   * @api private\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));\n  };\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @api private\n   */\n\n  _findOption(arg) {\n    return this.options.find(option => option.is(arg));\n  };\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Lazy calling after checking for help flags from leaf subcommand.\n   *\n   * @api private\n   */\n\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    for (let cmd = this; cmd; cmd = cmd.parent) {\n      cmd.options.forEach((anOption) => {\n        if (anOption.mandatory && (cmd.getOptionValue(anOption.attributeName()) === undefined)) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    }\n  };\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *     argv => operands, unknown\n   *     --known kkk op => [op], []\n   *     op --known kkk => [op], []\n   *     sub --unknown uuu op => [sub], [--unknown uuu op]\n   *     sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {String[]} argv\n   * @return {{operands: String[], unknown: String[]}}\n   */\n\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n    const unknown = []; // first unknown option and remaining unknown args\n    let dest = operands;\n    const args = argv.slice();\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    }\n\n    // parse options\n    let activeVariadicOption = null;\n    while (args.length) {\n      const arg = args.shift();\n\n      // literal\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg);\n        // recognised option, call listener to assign value with possible custom processing\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null;\n            // historical behaviour is optional value is following arg unless an option\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n            this.emit(`option:${option.name()}`, value);\n          } else { // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      }\n\n      // Look for combo options following single dash, eat first one if known.\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n        if (option) {\n          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n          continue;\n        }\n      }\n\n      // Look for known long flag with value, like --foo=bar\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n        const option = this._findOption(arg.slice(0, index));\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      }\n\n      // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n      if (maybeOption(arg)) {\n        dest = unknown;\n      }\n\n      // If using positionalOptions, stop processing our options at subcommand.\n      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {\n          operands.push(arg);\n          if (args.length > 0) operands.push(...args);\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        }\n      }\n\n      // If using passThroughOptions, stop processing options at first command-argument.\n      if (this._passThroughOptions) {\n        dest.push(arg);\n        if (args.length > 0) dest.push(...args);\n        break;\n      }\n\n      // add arg\n      dest.push(arg);\n    }\n\n    return { operands, unknown };\n  };\n\n  /**\n   * Return an object containing options as key-value pairs\n   *\n   * @return {Object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] = key === this._versionOptionName ? this._version : this[key];\n      }\n      return result;\n    }\n\n    return this._optionValues;\n  };\n\n  /**\n   * Internal bottleneck for handling of parsing errors.\n   *\n   * @api private\n   */\n  _displayError(exitCode, code, message) {\n    this._outputConfiguration.outputError(`${message}\\n`, this._outputConfiguration.writeErr);\n    if (typeof this._showHelpAfterError === 'string') {\n      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\\n`);\n    } else if (this._showHelpAfterError) {\n      this._outputConfiguration.writeErr('\\n');\n      this.outputHelp({ error: true });\n    }\n    this._exit(exitCode, code, message);\n  }\n\n  /**\n   * Apply any option related environment variables, if option does\n   * not have a value from cli or client code.\n   *\n   * @api private\n   */\n  _parseOptionsEnv() {\n    this.options.forEach((option) => {\n      if (option.envVar && option.envVar in process.env) {\n        const optionKey = option.attributeName();\n        // Priority check. Do not overwrite cli or options from unknown source (client-code).\n        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {\n          if (option.required || option.optional) { // option can take a value\n            // keep very simple, optional always takes value\n            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);\n          } else { // boolean\n            // keep very simple, only care that envVar defined and not the value\n            this.emit(`optionEnv:${option.name()}`);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @api private\n   */\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n    this._displayError(1, 'commander.missingArgument', message);\n  };\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n    this._displayError(1, 'commander.optionMissingArgument', message);\n  };\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n    this._displayError(1, 'commander.missingMandatoryOptionValue', message);\n  };\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @api private\n   */\n\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    let suggestion = '';\n\n    if (flag.startsWith('--') && this._showSuggestionAfterError) {\n      // Looping to pick up the global options too\n      let candidateFlags = [];\n      let command = this;\n      do {\n        const moreFlags = command.createHelp().visibleOptions(command)\n          .filter(option => option.long)\n          .map(option => option.long);\n        candidateFlags = candidateFlags.concat(moreFlags);\n        command = command.parent;\n      } while (command && !command._enablePositionalOptions);\n      suggestion = suggestSimilar(flag, candidateFlags);\n    }\n\n    const message = `error: unknown option '${flag}'${suggestion}`;\n    this._displayError(1, 'commander.unknownOption', message);\n  };\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @api private\n   */\n\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n\n    const expected = this._args.length;\n    const s = (expected === 1) ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n    this._displayError(1, 'commander.excessArguments', message);\n  };\n\n  /**\n   * Unknown command.\n   *\n   * @api private\n   */\n\n  unknownCommand() {\n    const unknownName = this.args[0];\n    let suggestion = '';\n\n    if (this._showSuggestionAfterError) {\n      const candidateNames = [];\n      this.createHelp().visibleCommands(this).forEach((command) => {\n        candidateNames.push(command.name());\n        // just visible alias\n        if (command.alias()) candidateNames.push(command.alias());\n      });\n      suggestion = suggestSimilar(unknownName, candidateNames);\n    }\n\n    const message = `error: unknown command '${unknownName}'${suggestion}`;\n    this._displayError(1, 'commander.unknownCommand', message);\n  };\n\n  /**\n   * Set the program version to `str`.\n   *\n   * This method auto-registers the \"-V, --version\" flag\n   * which will print the version number when passed.\n   *\n   * You can optionally supply the  flags and description to override the defaults.\n   *\n   * @param {string} str\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {this | string} `this` command for chaining, or version string if no arguments\n   */\n\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName();\n    this.options.push(versionOption);\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  };\n\n  /**\n   * Set the description to `str`.\n   *\n   * @param {string} [str]\n   * @param {Object} [argsDescription]\n   * @return {string|Command}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined) return this._description;\n    this._description = str;\n    if (argsDescription) {\n      this._argsDescription = argsDescription;\n    }\n    return this;\n  };\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {string|Command}\n   */\n\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    /** @type {Command} */\n    let command = this;\n    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n\n    command._aliases.push(alias);\n    return this;\n  };\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {string[]|Command}\n   */\n\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n\n    aliases.forEach((alias) => this.alias(alias));\n    return this;\n  };\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {String|Command}\n   */\n\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this._args.map((arg) => {\n        return humanReadableArgName(arg);\n      });\n      return [].concat(\n        (this.options.length || this._hasHelpOption ? '[options]' : []),\n        (this.commands.length ? '[command]' : []),\n        (this._args.length ? args : [])\n      ).join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  };\n\n  /**\n   * Get or set the name of the command\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  };\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n    if (helper.helpWidth === undefined) {\n      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();\n    }\n    return helper.formatHelp(this, helper);\n  };\n\n  /**\n   * @api private\n   */\n\n  _getHelpContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const context = { error: !!contextOptions.error };\n    let write;\n    if (context.error) {\n      write = (arg) => this._outputConfiguration.writeErr(arg);\n    } else {\n      write = (arg) => this._outputConfiguration.writeOut(arg);\n    }\n    context.write = contextOptions.write || write;\n    context.command = this;\n    return context;\n  }\n\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n    const context = this._getHelpContext(contextOptions);\n\n    getCommandAndParents(this).reverse().forEach(command => command.emit('beforeAllHelp', context));\n    this.emit('beforeHelp', context);\n\n    let helpInformation = this.helpInformation(context);\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n    context.write(helpInformation);\n\n    this.emit(this._helpLongFlag); // deprecated\n    this.emit('afterHelp', context);\n    getCommandAndParents(this).forEach(command => command.emit('afterAllHelp', context));\n  };\n\n  /**\n   * You can pass in flags and a description to override the help\n   * flags and help description for your command. Pass in false to\n   * disable the built-in help option.\n   *\n   * @param {string | boolean} [flags]\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n\n  helpOption(flags, description) {\n    if (typeof flags === 'boolean') {\n      this._hasHelpOption = flags;\n      return this;\n    }\n    this._helpFlags = flags || this._helpFlags;\n    this._helpDescription = description || this._helpDescription;\n\n    const helpFlags = splitOptionFlags(this._helpFlags);\n    this._helpShortFlag = helpFlags.shortFlag;\n    this._helpLongFlag = helpFlags.longFlag;\n\n    return this;\n  };\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = process.exitCode || 0;\n    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {\n      exitCode = 1;\n    }\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  };\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {string | Function} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, (context) => {\n      let helpStr;\n      if (typeof text === 'function') {\n        helpStr = text({ error: context.error, command: context.command });\n      } else {\n        helpStr = text;\n      }\n      // Ignore falsy value when nothing to output.\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n};\n\n/**\n * Output help information if help flags specified\n *\n * @param {Command} cmd - command to output help for\n * @param {Array} args - array of options to search for help flags\n * @api private\n */\n\nfunction outputHelpIfRequested(cmd, args) {\n  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);\n  if (helpOption) {\n    cmd.outputHelp();\n    // (Do not have all displayed text available so only passing placeholder.)\n    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n  }\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @api private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n      debugOption = match[1];\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n    return arg;\n  });\n}\n\n/**\n * @param {Command} startCommand\n * @returns {Command[]}\n * @api private\n */\n\nfunction getCommandAndParents(startCommand) {\n  const result = [];\n  for (let command = startCommand; command; command = command.parent) {\n    result.push(command);\n  }\n  return result;\n}\n\nexports.Command = Command;\n","// @ts-check\n\n/**\n * CommanderError class\n * @class\n */\nclass CommanderError extends Error {\n  /**\n   * Constructs the CommanderError class\n   * @param {number} exitCode suggested exit code which could be used with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @constructor\n   */\n  constructor(exitCode, code, message) {\n    super(message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.exitCode = exitCode;\n    this.nestedError = undefined;\n  }\n}\n\n/**\n * InvalidArgumentError class\n * @class\n */\nclass InvalidArgumentError extends CommanderError {\n  /**\n   * Constructs the InvalidArgumentError class\n   * @param {string} [message] explanation of why argument is invalid\n   * @constructor\n   */\n  constructor(message) {\n    super(1, 'commander.invalidArgument', message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n  }\n}\n\nexports.CommanderError = CommanderError;\nexports.InvalidArgumentError = InvalidArgumentError;\n","const { humanReadableArgName } = require('./argument.js');\n\n/**\n * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option\n */\n\n// @ts-check\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n    if (cmd._hasImplicitHelpCommand()) {\n      // Create a command matching the implicit help command.\n      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);\n      const helpCommand = cmd.createCommand(helpName)\n        .helpOption(false);\n      helpCommand.description(cmd._helpCommandDescription);\n      if (helpArgs) helpCommand.arguments(helpArgs);\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        // @ts-ignore: overloaded return type\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter((option) => !option.hidden);\n    // Implicit help\n    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);\n    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpOption;\n      if (!showShortHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);\n      } else if (!showLongHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);\n      } else {\n        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);\n      }\n      visibleOptions.push(helpOption);\n    }\n    if (this.sortOptions) {\n      const getSortKey = (option) => {\n        // WYSIWYG for order displayed in help with short before long, no special handling for negated.\n        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n      };\n      visibleOptions.sort((a, b) => {\n        return getSortKey(a).localeCompare(getSortKey(b));\n      });\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the arguments if any have a description.\n   *\n   * @param {Command} cmd\n   * @returns {Argument[]}\n   */\n\n  visibleArguments(cmd) {\n    // Side effect! Apply the legacy descriptions before the arguments are displayed.\n    if (cmd._argsDescription) {\n      cmd._args.forEach(argument => {\n        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';\n      });\n    }\n\n    // If there are any arguments with a description then return all the arguments.\n    if (cmd._args.find(argument => argument.description)) {\n      return cmd._args;\n    };\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');\n    return cmd._name +\n      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +\n      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option\n      (args ? ' ' + args : '');\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the argument term to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @returns {string}\n   */\n\n  argumentTerm(argument) {\n    return argument.name();\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  };\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  };\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, helper.argumentTerm(argument).length);\n    }, 0);\n  };\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let parentCmdNames = '';\n    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {\n      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;\n    }\n    return parentCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the command description to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    const extraInfo = [];\n    // Some of these do not make sense for negated boolean and suppress for backwards compatibility.\n\n    if (option.argChoices && !option.negate) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (option.defaultValue !== undefined && !option.negate) {\n      extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n    }\n    if (option.envVar !== undefined) {\n      extraInfo.push(`env: ${option.envVar}`);\n    }\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n\n    return option.description;\n  };\n\n  /**\n   * Get the argument description to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @return {string}\n   */\n\n  argumentDescription(argument) {\n    const extraInfo = [];\n    if (argument.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (argument.defaultValue !== undefined) {\n      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);\n    }\n    if (extraInfo.length > 0) {\n      const extraDescripton = `(${extraInfo.join(', ')})`;\n      if (argument.description) {\n        return `${argument.description} ${extraDescripton}`;\n      }\n      return extraDescripton;\n    }\n    return argument.description;\n  }\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n      return term;\n    };\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    }\n\n    // Usage\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([commandDescription, '']);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map((argument) => {\n      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));\n    });\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    }\n\n    // Options\n    const optionList = helper.visibleOptions(cmd).map((option) => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    }\n\n    // Commands\n    const commandList = helper.visibleCommands(cmd).map((cmd) => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(\n      helper.longestOptionTermLength(cmd, helper),\n      helper.longestSubcommandTermLength(cmd, helper),\n      helper.longestArgumentTermLength(cmd, helper)\n    );\n  };\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n\n  wrap(str, width, indent, minColumnWidth = 40) {\n    // Detect manually wrapped and indented strings by searching for line breaks\n    // followed by multiple spaces/tabs.\n    if (str.match(/[\\n]\\s+/)) return str;\n    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n\n    const leadingStr = str.substr(0, indent);\n    const columnText = str.substr(indent);\n\n    const indentString = ' '.repeat(indent);\n    const regex = new RegExp('.{1,' + (columnWidth - 1) + '}([\\\\s\\u200B]|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]|$)', 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line.slice(-1) === '\\n') {\n        line = line.slice(0, line.length - 1);\n      }\n      return ((i > 0) ? indentString : '') + line.trimRight();\n    }).join('\\n');\n  }\n}\n\nexports.Help = Help;\n","const { InvalidArgumentError } = require('./error.js');\n\n// @ts-check\n\nclass Option {\n  /**\n   * Initialize a new `Option` with the given `flags` and `description`.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   */\n\n  constructor(flags, description) {\n    this.flags = flags;\n    this.description = description || '';\n\n    this.required = flags.includes('<'); // A value must be supplied when the option is specified.\n    this.optional = flags.includes('['); // A value is optional when the option is specified.\n    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument\n    this.variadic = /\\w\\.\\.\\.[>\\]]$/.test(flags); // The option can take multiple values.\n    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n    const optionFlags = splitOptionFlags(flags);\n    this.short = optionFlags.shortFlag;\n    this.long = optionFlags.longFlag;\n    this.negate = false;\n    if (this.long) {\n      this.negate = this.long.startsWith('--no-');\n    }\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.envVar = undefined;\n    this.parseArg = undefined;\n    this.hidden = false;\n    this.argChoices = undefined;\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {any} value\n   * @param {string} [description]\n   * @return {Option}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  };\n\n  /**\n   * Set environment variable to check for option value.\n   * Priority order of option values is default < env < cli\n   *\n   * @param {string} name\n   * @return {Option}\n   */\n\n  env(name) {\n    this.envVar = name;\n    return this;\n  };\n\n  /**\n   * Set the custom handler for processing CLI option arguments into option values.\n   *\n   * @param {Function} [fn]\n   * @return {Option}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  };\n\n  /**\n   * Whether the option is mandatory and must have a value after parsing.\n   *\n   * @param {boolean} [mandatory=true]\n   * @return {Option}\n   */\n\n  makeOptionMandatory(mandatory = true) {\n    this.mandatory = !!mandatory;\n    return this;\n  };\n\n  /**\n   * Hide option in help.\n   *\n   * @param {boolean} [hide=true]\n   * @return {Option}\n   */\n\n  hideHelp(hide = true) {\n    this.hidden = !!hide;\n    return this;\n  };\n\n  /**\n   * @api private\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Option}\n   */\n\n  choices(values) {\n    this.argChoices = values;\n    this.parseArg = (arg, previous) => {\n      if (!values.includes(arg)) {\n        throw new InvalidArgumentError(`Allowed choices are ${values.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  };\n\n  /**\n   * Return option name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    if (this.long) {\n      return this.long.replace(/^--/, '');\n    }\n    return this.short.replace(/^-/, '');\n  };\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as a object attribute key.\n   *\n   * @return {string}\n   * @api private\n   */\n\n  attributeName() {\n    return camelcase(this.name().replace(/^no-/, ''));\n  };\n\n  /**\n   * Check if `arg` matches the short or long flag.\n   *\n   * @param {string} arg\n   * @return {boolean}\n   * @api private\n   */\n\n  is(arg) {\n    return this.short === arg || this.long === arg;\n  };\n}\n\n/**\n * Convert string from kebab-case to camelCase.\n *\n * @param {string} str\n * @return {string}\n * @api private\n */\n\nfunction camelcase(str) {\n  return str.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Split the short and long flag out of something like '-m,--mixed <value>'\n *\n * @api private\n */\n\nfunction splitOptionFlags(flags) {\n  let shortFlag;\n  let longFlag;\n  // Use original very loose parsing to maintain backwards compatibility for now,\n  // which allowed for example unintended `-sw, --short-word` [sic].\n  const flagParts = flags.split(/[ |,]+/);\n  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();\n  longFlag = flagParts.shift();\n  // Add support for lone short flag without significantly changing parsing!\n  if (!shortFlag && /^-[^-]$/.test(longFlag)) {\n    shortFlag = longFlag;\n    longFlag = undefined;\n  }\n  return { shortFlag, longFlag };\n}\n\nexports.Option = Option;\nexports.splitOptionFlags = splitOptionFlags;\n","const maxDistance = 3;\n\nfunction editDistance(a, b) {\n  // https://en.wikipedia.org/wiki/DamerauLevenshtein_distance\n  // Calculating optimal string alignment distance, no substring is edited more than once.\n  // (Simple implementation.)\n\n  // Quick early exit, return worst case.\n  if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);\n\n  // distance between prefix substrings of a and b\n  const d = [];\n\n  // pure deletions turn a into empty string\n  for (let i = 0; i <= a.length; i++) {\n    d[i] = [i];\n  }\n  // pure insertions turn empty string into b\n  for (let j = 0; j <= b.length; j++) {\n    d[0][j] = j;\n  }\n\n  // fill matrix\n  for (let j = 1; j <= b.length; j++) {\n    for (let i = 1; i <= a.length; i++) {\n      let cost = 1;\n      if (a[i - 1] === b[j - 1]) {\n        cost = 0;\n      } else {\n        cost = 1;\n      }\n      d[i][j] = Math.min(\n        d[i - 1][j] + 1, // deletion\n        d[i][j - 1] + 1, // insertion\n        d[i - 1][j - 1] + cost // substitution\n      );\n      // transposition\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);\n      }\n    }\n  }\n\n  return d[a.length][b.length];\n}\n\n/**\n * Find close matches, restricted to same number of edits.\n *\n * @param {string} word\n * @param {string[]} candidates\n * @returns {string}\n */\n\nfunction suggestSimilar(word, candidates) {\n  if (!candidates || candidates.length === 0) return '';\n  // remove possible duplicates\n  candidates = Array.from(new Set(candidates));\n\n  const searchingOptions = word.startsWith('--');\n  if (searchingOptions) {\n    word = word.slice(2);\n    candidates = candidates.map(candidate => candidate.slice(2));\n  }\n\n  let similar = [];\n  let bestDistance = maxDistance;\n  const minSimilarity = 0.4;\n  candidates.forEach((candidate) => {\n    if (candidate.length <= 1) return; // no one character guesses\n\n    const distance = editDistance(word, candidate);\n    const length = Math.max(word.length, candidate.length);\n    const similarity = (length - distance) / length;\n    if (similarity > minSimilarity) {\n      if (distance < bestDistance) {\n        // better edit distance, throw away previous worse matches\n        bestDistance = distance;\n        similar = [candidate];\n      } else if (distance === bestDistance) {\n        similar.push(candidate);\n      }\n    }\n  });\n\n  similar.sort((a, b) => a.localeCompare(b));\n  if (searchingOptions) {\n    similar = similar.map(candidate => `--${candidate}`);\n  }\n\n  if (similar.length > 1) {\n    return `\\n(Did you mean one of ${similar.join(', ')}?)`;\n  }\n  if (similar.length === 1) {\n    return `\\n(Did you mean ${similar[0]}?)`;\n  }\n  return '';\n}\n\nexports.suggestSimilar = suggestSimilar;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","#!/usr/bin/env node\r\n\r\n// Example run: node cli.js -cs lower -cpx high\r\n\r\nimport { program } from 'commander';\r\nimport {generateMonster} from './index';\r\n\r\nprogram\r\n  .option(\r\n    \"-cpx --complexity <complexity>\",\r\n    \"Option how many adjectives return value as: low | medium | high\",\r\n    \"low\"\r\n  )\r\n  .option(\r\n    \"-cs --casing <casing>\",\r\n    \"Option how the return string is formatted: capitalize | upper | lower\"\r\n  )\r\n  .parse();\r\n\r\nconst options = program.opts();\r\nif (options.complexity) console.log(`Option <complexity>: ${options.complexity}`);\r\nif (options.casing) console.log(`Option <casing>: ${options.casing}`);\r\n\r\nconsole.log(\r\n  \"Result:\",\r\n  generateMonster({\r\n    complexity: options.complexity,\r\n    casing: options.casing,\r\n  })\r\n);\r\n","module.exports=[\"red\", \"blue\", \"green\", \"yellow\", \"purple\"]\n","module.exports=[\"round-eyed\", \"square-eyed\", \"googly-eyed\"]\n","module.exports=[\"alien\", \"monster\"]\n","module.exports=[\"smiling\", \"grinning\", \"pouting\", \"screaming\"]\r\n","module.exports=[\"round\", \"square\", \"oval\"]\n","module.exports=[\"tiny\", \"small\", \"huge\", \"enormous\"]\n","import { IOptions } from \"./types\";\r\nimport { generate } from \"./monsterGenerator\";\r\n\r\nexport const generateMonster = (options: IOptions) => {\r\n  return generate(options);\r\n};\r\n","import colors from \"./data/color-options.json\";\r\nimport sizes from \"./data/size-options.json\";\r\nimport shapes from \"./data/shape-options.json\";\r\nimport mood from \"./data/mood-options.json\";\r\nimport eyes from \"./data/eye-options.json\";\r\nimport monsters from \"./data/monster-options.json\";\r\nimport { getRandomValue } from \"./randomValueGenerator\";\r\nimport { IMonster, IMonsterProps, IOptions } from \"./types\";\r\nimport { format } from \"./stringFormatter\";\r\n\r\nexport const generate = (options: IOptions) => {\r\n  const { complexity, casing } = options;\r\n\r\n  const result: IMonster = {\r\n    stringified: \"\",\r\n    properties: {},\r\n  };\r\n\r\n  if (complexity === \"high\") {\r\n    result.properties.size = getRandomValue(sizes);\r\n    result.properties.mood = getRandomValue(mood);\r\n  }\r\n\r\n  if (complexity === \"high\" || complexity === \"medium\") {\r\n    result.properties.eyes = getRandomValue(eyes);\r\n    result.properties.shape = getRandomValue(shapes);\r\n  }\r\n\r\n  result.properties.color = getRandomValue(colors);\r\n  result.properties.type = getRandomValue(monsters);\r\n\r\n  const str = toString(result.properties);\r\n  result.stringified = format(str, casing);\r\n  return result;\r\n};\r\n\r\n/**\r\n * Loop through monster properties and add values to string with spaces\r\n * Trim the space at the end\r\n * @param props\r\n * @returns string of properties with spaces between values\r\n */\r\nconst toString = (props: IMonsterProps) => {\r\n  const arr = [];\r\n  for (const prop in props) {\r\n    arr.push(props[prop as keyof IMonsterProps]);\r\n  }\r\n\r\n  return arr.join(\" \");\r\n};\r\n","/**\r\n * @param values\r\n * @returns Random value from @values using Math.random\r\n */\r\nexport const getRandomValue = (values: Array<string>) => {\r\n  return values[Math.floor(Math.random() * values.length)];\r\n};\r\n\r\n/**\r\n * @param max\r\n * @param min\r\n * @returns Get value between @max and @min\r\n */\r\nexport const getRandomNumber = (max: number, min: number = 0) => {\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n};\r\n","import { Casing } from \"./types\";\r\n\r\nconst capitalize = (string: string) => {\r\n  return string.charAt(0).toUpperCase() + string.slice(1);\r\n};\r\n\r\nexport const format = (str: string, casing?: Casing) => {\r\n  switch (casing) {\r\n    case \"capitalize\":\r\n      return capitalize(str);\r\n    case \"upper\":\r\n      return str.toUpperCase();\r\n    case \"lower\":\r\n      return str.toLocaleLowerCase();\r\n    default:\r\n      return str;\r\n  }\r\n};\r\n"]}