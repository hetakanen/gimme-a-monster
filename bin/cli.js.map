{"version":3,"sources":["node_modules/browser-pack/_prelude.js","cli.js","dist/index.js","node_modules/commander/index.js","node_modules/commander/lib/argument.js","node_modules/commander/lib/command.js","node_modules/commander/lib/error.js","node_modules/commander/lib/help.js","node_modules/commander/lib/option.js","node_modules/commander/lib/suggestSimilar.js","node_modules/events/events.js","node_modules/is-buffer/index.js","node_modules/path-browserify/index.js","node_modules/process/browser.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","program","generateMonster","option","parse","options","opts","complexity","console","log","casing","s","2","3","4","5","6","7","Object","defineProperty","value","generate","./monsterGenerator","8","this","__importDefault","__esModule","default","d","l","stringified","properties","size","getRandomValue","mood","eyes","shape","color","type","format","push","join","./data/color-options.json","./data/eye-options.json","./data/monster-options.json","./data/mood-options.json","./data/shape-options.json","./data/size-options.json","./randomValueGenerator","./stringFormatter","9","getRandomNumber","Math","floor","random","10","charAt","toUpperCase","slice","toLocaleLowerCase","Argument","Command","CommanderError","InvalidArgumentError","Help","Option","InvalidOptionArgumentError","constructor","name","description","variadic","parseArg","undefined","defaultValue","defaultValueDescription","argChoices","required","_name","_concatValue","previous","Array","isArray","concat","argParser","fn","choices","values","arg","includes","argRequired","argOptional","humanReadableArgName","nameOutput","EventEmitter","childProcess","path","fs","splitOptionFlags","suggestSimilar","super","commands","parent","_allowUnknownOption","_allowExcessArguments","_args","args","rawArgs","processedArgs","_scriptPath","_optionValues","_optionValueSources","_storeOptionsAsProperties","_actionHandler","_executableHandler","_executableFile","_defaultCommandName","_exitCallback","_aliases","_combineFlagAndOptionalValue","_description","_argsDescription","_enablePositionalOptions","_passThroughOptions","_lifeCycleHooks","_showHelpAfterError","_showSuggestionAfterError","_outputConfiguration","writeOut","process","stdout","write","str","writeErr","stderr","getOutHelpWidth","isTTY","columns","getErrHelpWidth","outputError","_hidden","_hasHelpOption","_helpFlags","_helpDescription","_helpShortFlag","_helpLongFlag","_addImplicitHelpCommand","_helpCommandName","_helpCommandnameAndArgs","_helpCommandDescription","_helpConfiguration","copyInheritedSettings","sourceCommand","command","nameAndArgs","actionOptsOrExecDesc","execOpts","let","desc","match","cmd","createCommand","isDefault","noHelp","hidden","executableFile","arguments","createHelp","assign","configureHelp","configuration","configureOutput","showHelpAfterError","displayHelp","showSuggestionAfterError","displaySuggestion","addCommand","checkExplicitNames","commandArray","forEach","createArgument","argument","addArgument","names","split","detail","previousArgument","addHelpCommand","enableOrNameAndArgs","_hasImplicitHelpCommand","_findCommand","hook","event","listener","allowedValues","exitOverride","err","_exit","exitCode","message","exit","action","expectedArgsCount","actionArgs","apply","createOption","flags","addOption","positiveLongFlag","oname","attributeName","negate","optional","long","replace","_findOption","getOptionValue","setOptionValueWithSource","handleOptionValue","val","invalidValueMessage","valueSource","oldValue","_displayError","on","envVar","_optionEx","config","makeOptionMandatory","mandatory","RegExp","regex","def","m","exec","requiredOption","combineFlagAndOptionalValue","combine","allowUnknownOption","allowUnknown","allowExcessArguments","allowExcess","enablePositionalOptions","positional","passThroughOptions","passThrough","storeOptionsAsProperties","storeAsProperties","key","setOptionValue","source","getOptionValueSource","_prepareUserArgs","argv","parseOptions","versions","electron","from","userArgs","defaultApp","main","filename","basename","extname","_parseCommand","parseAsync","_executeSubCommand","subcommand","sourceExt","_checkForMissingMandatoryOptions","scriptPath","baseDir","resolvedLink","realpathSync","dirname","bin","localBin","existsSync","ext","launchWithNode","proc","platform","unshift","incrementNodeInspectorPort","execArgv","spawn","stdio","execPath","signal","killed","kill","exitCallback","bind","executableMissing","wrappedError","nestedError","runningCommand","_dispatchSubcommand","commandName","operands","unknown","subCommand","help","error","_checkNumberOfArguments","missingArgument","_excessArguments","_processArguments","myParseArg","parsedValue","declaredArg","index","reduce","processed","v","_chainOrCall","promise","then","_chainOrCallHooks","result","hooks","getCommandAndParents","reverse","filter","hookedCommand","callback","hookDetail","parsed","_parseOptionsEnv","outputHelpIfRequested","actionResult","checkForUnknownOptions","unknownOption","commandEvent","emit","listenerCount","unknownCommand","find","is","anOption","missingMandatoryOptionValue","dest","maybeOption","activeVariadicOption","shift","optionMissingArgument","test","indexOf","len","_versionOptionName","_version","outputHelp","optionKey","env","flag","suggestion","startsWith","candidateFlags","moreFlags","visibleOptions","map","receivedArgs","expected","unknownName","candidateNames","visibleCommands","alias","version","versionOption","argsDescription","aliases","usage","_usage","helpInformation","contextOptions","helper","helpWidth","formatHelp","_getHelpContext","context","deprecatedCallback","Buffer","isBuffer","helpOption","helpFlags","shortFlag","longFlag","addHelpText","position","text","helpStr","debugOption","debugHost","debugPort","parseInt","startCommand","captureStackTrace","sortSubcommands","sortOptions","helpName","helpArgs","helpCommand","sort","b","localeCompare","showShortHelpFlag","showLongHelpFlag","getSortKey","short","visibleArguments","subcommandTerm","optionTerm","argumentTerm","longestSubcommandTermLength","max","longestOptionTermLength","longestArgumentTermLength","commandUsage","cmdName","parentCmdNames","parentCmd","commandDescription","subcommandDescription","optionDescription","extraInfo","JSON","stringify","choice","argumentDescription","extraDescripton","termWidth","padWidth","formatItem","term","fullText","padEnd","wrap","formatList","textArray","repeat","output","argumentList","optionList","commandList","width","indent","minColumnWidth","columnWidth","leadingStr","substr","columnText","indentString","lines","line","trimRight","flagParts","optionFlags","hideHelp","hide","word","maxDistance","candidates","Set","searchingOptions","candidate","similar","bestDistance","distance","abs","j","cost","min","editDistance","R","Reflect","ReflectApply","target","receiver","Function","prototype","ReflectOwnKeys","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","NumberIsNaN","Number","isNaN","init","once","emitter","Promise","resolve","reject","errorListener","removeListener","resolver","handler","eventTargetAgnosticAddListener","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","TypeError","_getMaxListeners","that","_addListener","prepend","events","existing","create","newListener","warned","w","String","count","warning","warn","_onceWrap","state","fired","wrapFn","wrapped","_listeners","unwrap","evlistener","arr","ret","unwrapListeners","arrayClone","copy","addEventListener","wrapListener","removeEventListener","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","er","doError","listeners","addListener","prependListener","prependOnceListener","off","list","originalListener","pop","spliceOne","removeAllListeners","keys","rawListeners","eventNames","obj","readFloatLE","_isBuffer","assertPath","normalizeStringPosix","allowAboveRoot","res","lastSegmentLength","lastSlash","dots","charCodeAt","lastSlashIndex","lastIndexOf","posix","cwd","resolvedPath","resolvedAbsolute","normalize","isAbsolute","trailingSeparator","joined","relative","to","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","hasRoot","end","matchedSlash","start","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","pathObject","sep","dir","root","base","delimiter","win32","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","array","noop","nextTick","title","browser","binding","chdir","umask"],"mappings":"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","file":"cli.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\n\n// Example run: node cli.js -cs lower -cpx high\nconst { program } = require('commander');\nconst generateMonster = require('./dist/index.js');\n// import { program } from 'commander';\n// import {generateMonster} from './dist/index.js';\n\nprogram\n  .option(\n    \"-cpx --complexity <complexity>\",\n    \"Option how many adjectives return value as: low | medium | high\",\n    \"low\"\n  )\n  .option(\n    \"-cs --casing <casing>\",\n    \"Option how the return string is formatted: capitalize | upper | lower\"\n  )\n  .parse();\n\nconst options = program.opts();\nif (options.complexity) console.log(`Option <complexity>: ${options.complexity}`);\nif (options.casing) console.log(`Option <casing>: ${options.casing}`);\n\nconsole.log(\n  \"Result:\",\n  generateMonster({\n    complexity: options.complexity,\n    casing: options.casing,\n  })\n);","!function r(n,a,s){function i(o,e){if(!a[o]){if(!n[o]){var t=\"function\"==typeof require&&require;if(!e&&t)return t(o,!0);if(u)return u(o,!0);throw(t=new Error(\"Cannot find module '\"+o+\"'\")).code=\"MODULE_NOT_FOUND\",t}t=a[o]={exports:{}},n[o][0].call(t.exports,function(e){return i(n[o][1][e]||e)},t,t.exports,r,n,a,s)}return a[o].exports}for(var u=\"function\"==typeof require&&require,e=0;e<s.length;e++)i(s[e]);return i}({1:[function(e,o,t){o.exports=[\"red\",\"blue\",\"green\",\"yellow\",\"purple\"]},{}],2:[function(e,o,t){o.exports=[\"round-eyed\",\"square-eyed\",\"googly-eyed\"]},{}],3:[function(e,o,t){o.exports=[\"alien\",\"monster\"]},{}],4:[function(e,o,t){o.exports=[\"smiling\",\"grinning\",\"pouting\",\"screaming\"]},{}],5:[function(e,o,t){o.exports=[\"round\",\"square\",\"oval\"]},{}],6:[function(e,o,t){o.exports=[\"tiny\",\"small\",\"huge\",\"enormous\"]},{}],7:[function(e,o,t){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.generateMonster=void 0;const r=e(\"./monsterGenerator\");t.generateMonster=e=>(0,r.generate)(e)},{\"./monsterGenerator\":8}],8:[function(e,o,t){\"use strict\";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,\"__esModule\",{value:!0}),t.generate=void 0;const n=r(e(\"./data/color-options.json\")),a=r(e(\"./data/size-options.json\")),s=r(e(\"./data/shape-options.json\")),i=r(e(\"./data/mood-options.json\")),u=r(e(\"./data/eye-options.json\")),d=r(e(\"./data/monster-options.json\")),p=e(\"./randomValueGenerator\"),l=e(\"./stringFormatter\");t.generate=e=>{var{complexity:o,casing:e}=e;const t={stringified:\"\",properties:{}};\"high\"===o&&(t.properties.size=(0,p.getRandomValue)(a.default),t.properties.mood=(0,p.getRandomValue)(i.default)),\"high\"!==o&&\"medium\"!==o||(t.properties.eyes=(0,p.getRandomValue)(u.default),t.properties.shape=(0,p.getRandomValue)(s.default)),t.properties.color=(0,p.getRandomValue)(n.default),t.properties.type=(0,p.getRandomValue)(d.default);o=c(t.properties);return t.stringified=(0,l.format)(o,e),t};const c=e=>{const o=[];for(const t in e)o.push(e[t]);return o.join(\" \")}},{\"./data/color-options.json\":1,\"./data/eye-options.json\":2,\"./data/monster-options.json\":3,\"./data/mood-options.json\":4,\"./data/shape-options.json\":5,\"./data/size-options.json\":6,\"./randomValueGenerator\":9,\"./stringFormatter\":10}],9:[function(e,o,t){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.getRandomNumber=t.getRandomValue=void 0;t.getRandomValue=e=>e[Math.floor(Math.random()*e.length)];t.getRandomNumber=(e,o=0)=>Math.floor(Math.random()*(e-o+1)+o)},{}],10:[function(e,o,t){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.format=void 0;t.format=(e,o)=>{switch(o){case\"capitalize\":return(t=e).charAt(0).toUpperCase()+t.slice(1);case\"upper\":return e.toUpperCase();case\"lower\":return e.toLocaleLowerCase();default:return e}var t}},{}]},{},[7]);\n//# sourceMappingURL=index.js.map\n","const { Argument } = require('./lib/argument.js');\nconst { Command } = require('./lib/command.js');\nconst { CommanderError, InvalidArgumentError } = require('./lib/error.js');\nconst { Help } = require('./lib/help.js');\nconst { Option } = require('./lib/option.js');\n\n// @ts-check\n\n/**\n * Expose the root command.\n */\n\nexports = module.exports = new Command();\nexports.program = exports; // More explicit access to global command.\n// Implicit export of createArgument, createCommand, and createOption.\n\n/**\n * Expose classes\n */\n\nexports.Argument = Argument;\nexports.Command = Command;\nexports.CommanderError = CommanderError;\nexports.Help = Help;\nexports.InvalidArgumentError = InvalidArgumentError;\nexports.InvalidOptionArgumentError = InvalidArgumentError; // Deprecated\nexports.Option = Option;\n","const { InvalidArgumentError } = require('./error.js');\n\n// @ts-check\n\nclass Argument {\n  /**\n   * Initialize a new command argument with the given name and description.\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   */\n\n  constructor(name, description) {\n    this.description = description || '';\n    this.variadic = false;\n    this.parseArg = undefined;\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.argChoices = undefined;\n\n    switch (name[0]) {\n      case '<': // e.g. <required>\n        this.required = true;\n        this._name = name.slice(1, -1);\n        break;\n      case '[': // e.g. [optional]\n        this.required = false;\n        this._name = name.slice(1, -1);\n        break;\n      default:\n        this.required = true;\n        this._name = name;\n        break;\n    }\n\n    if (this._name.length > 3 && this._name.slice(-3) === '...') {\n      this.variadic = true;\n      this._name = this._name.slice(0, -3);\n    }\n  }\n\n  /**\n   * Return argument name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    return this._name;\n  };\n\n  /**\n   * @api private\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {any} value\n   * @param {string} [description]\n   * @return {Argument}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  };\n\n  /**\n   * Set the custom handler for processing CLI command arguments into argument values.\n   *\n   * @param {Function} [fn]\n   * @return {Argument}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  };\n\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Argument}\n   */\n\n  choices(values) {\n    this.argChoices = values;\n    this.parseArg = (arg, previous) => {\n      if (!values.includes(arg)) {\n        throw new InvalidArgumentError(`Allowed choices are ${values.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  };\n\n  /**\n   * Make option-argument required.\n   */\n  argRequired() {\n    this.required = true;\n    return this;\n  }\n\n  /**\n   * Make option-argument optional.\n   */\n  argOptional() {\n    this.required = false;\n    return this;\n  }\n}\n\n/**\n * Takes an argument and returns its human readable equivalent for help usage.\n *\n * @param {Argument} arg\n * @return {string}\n * @api private\n */\n\nfunction humanReadableArgName(arg) {\n  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');\n\n  return arg.required\n    ? '<' + nameOutput + '>'\n    : '[' + nameOutput + ']';\n}\n\nexports.Argument = Argument;\nexports.humanReadableArgName = humanReadableArgName;\n","const EventEmitter = require('events').EventEmitter;\nconst childProcess = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\n\nconst { Argument, humanReadableArgName } = require('./argument.js');\nconst { CommanderError } = require('./error.js');\nconst { Help } = require('./help.js');\nconst { Option, splitOptionFlags } = require('./option.js');\nconst { suggestSimilar } = require('./suggestSimilar');\n\n// @ts-check\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n\n  constructor(name) {\n    super();\n    /** @type {Command[]} */\n    this.commands = [];\n    /** @type {Option[]} */\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = true;\n    /** @type {Argument[]} */\n    this._args = [];\n    /** @type {string[]} */\n    this.args = []; // cli args with options removed\n    this.rawArgs = [];\n    this.processedArgs = []; // like .args but after custom processing and collecting variadic\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._optionValueSources = {}; // default < config < env < cli\n    this._storeOptionsAsProperties = false;\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._argsDescription = undefined; // legacy\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false;\n    this._lifeCycleHooks = {}; // a hash of arrays\n    /** @type {boolean | string} */\n    this._showHelpAfterError = false;\n    this._showSuggestionAfterError = false;\n\n    // see .configureOutput() for docs\n    this._outputConfiguration = {\n      writeOut: (str) => process.stdout.write(str),\n      writeErr: (str) => process.stderr.write(str),\n      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,\n      outputError: (str, write) => write(str)\n    };\n\n    this._hidden = false;\n    this._hasHelpOption = true;\n    this._helpFlags = '-h, --help';\n    this._helpDescription = 'display help for command';\n    this._helpShortFlag = '-h';\n    this._helpLongFlag = '--help';\n    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false\n    this._helpCommandName = 'help';\n    this._helpCommandnameAndArgs = 'help [command]';\n    this._helpCommandDescription = 'display help for command';\n    this._helpConfiguration = {};\n  }\n\n  /**\n   * Copy settings that are useful to have in common across root command and subcommands.\n   *\n   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)\n   *\n   * @param {Command} sourceCommand\n   * @return {Command} returns `this` for executable command\n   */\n  copyInheritedSettings(sourceCommand) {\n    this._outputConfiguration = sourceCommand._outputConfiguration;\n    this._hasHelpOption = sourceCommand._hasHelpOption;\n    this._helpFlags = sourceCommand._helpFlags;\n    this._helpDescription = sourceCommand._helpDescription;\n    this._helpShortFlag = sourceCommand._helpShortFlag;\n    this._helpLongFlag = sourceCommand._helpLongFlag;\n    this._helpCommandName = sourceCommand._helpCommandName;\n    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;\n    this._helpCommandDescription = sourceCommand._helpCommandDescription;\n    this._helpConfiguration = sourceCommand._helpConfiguration;\n    this._exitCallback = sourceCommand._exitCallback;\n    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;\n    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;\n    this._allowExcessArguments = sourceCommand._allowExcessArguments;\n    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;\n    this._showHelpAfterError = sourceCommand._showHelpAfterError;\n    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;\n\n    return this;\n  }\n\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * @example\n   * // Command implemented using action handler (description is supplied separately to `.command`)\n   * program\n   *   .command('clone <source> [destination]')\n   *   .description('clone a repository into a newly created directory')\n   *   .action((source, destination) => {\n   *     console.log('clone command called');\n   *   });\n   *\n   * // Command implemented using separate executable file (description is second parameter to `.command`)\n   * program\n   *   .command('start <service>', 'start named service')\n   *   .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {Object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n    opts = opts || {};\n    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);\n\n    const cmd = this.createCommand(name);\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n    if (args) cmd.arguments(args);\n    this.commands.push(cmd);\n    cmd.parent = this;\n    cmd.copyInheritedSettings(this);\n\n    if (desc) return this;\n    return cmd;\n  };\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n\n  createCommand(name) {\n    return new Command(name);\n  };\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  };\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n\n    this._helpConfiguration = configuration;\n    return this;\n  }\n\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *     // functions to change where being written, stdout and stderr\n   *     writeOut(str)\n   *     writeErr(str)\n   *     // matching functions to specify width for wrapping help\n   *     getOutHelpWidth()\n   *     getErrHelpWidth()\n   *     // functions based on what is being written out\n   *     outputError(str, write) // used for displaying errors, and not used for displaying help\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n\n    Object.assign(this._outputConfiguration, configuration);\n    return this;\n  }\n\n  /**\n   * Display the help or a custom message after an error occurs.\n   *\n   * @param {boolean|string} [displayHelp]\n   * @return {Command} `this` command for chaining\n   */\n  showHelpAfterError(displayHelp = true) {\n    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;\n    this._showHelpAfterError = displayHelp;\n    return this;\n  }\n\n  /**\n   * Display suggestion of similar commands for unknown commands, or options for unknown options.\n   *\n   * @param {boolean} [displaySuggestion]\n   * @return {Command} `this` command for chaining\n   */\n  showSuggestionAfterError(displaySuggestion = true) {\n    this._showSuggestionAfterError = !!displaySuggestion;\n    return this;\n  }\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {Object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) throw new Error('Command passed to .addCommand() must have a name');\n\n    // To keep things simple, block automatic name generation for deeply nested executables.\n    // Fail fast and detect when adding rather than later when parsing.\n    function checkExplicitNames(commandArray) {\n      commandArray.forEach((cmd) => {\n        if (cmd._executableHandler && !cmd._executableFile) {\n          throw new Error(`Must specify executableFile for deeply nested executable: ${cmd.name()}`);\n        }\n        checkExplicitNames(cmd.commands);\n      });\n    }\n    checkExplicitNames(cmd.commands);\n\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this.commands.push(cmd);\n    cmd.parent = this;\n    return this;\n  };\n\n  /**\n   * Factory routine to create a new unattached argument.\n   *\n   * See .argument() for creating an attached argument, which uses this routine to\n   * create the argument. You can override createArgument to return a custom argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @return {Argument} new argument\n   */\n\n  createArgument(name, description) {\n    return new Argument(name, description);\n  };\n\n  /**\n   * Define argument syntax for command.\n   *\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @example\n   * program.argument('<input-file>');\n   * program.argument('[output-file]');\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom argument processing function\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n  argument(name, description, fn, defaultValue) {\n    const argument = this.createArgument(name, description);\n    if (typeof fn === 'function') {\n      argument.default(defaultValue).argParser(fn);\n    } else {\n      argument.default(fn);\n    }\n    this.addArgument(argument);\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding multiple at once (without descriptions).\n   *\n   * See also .argument().\n   *\n   * @example\n   * program.arguments('<cmd> [env]');\n   *\n   * @param {string} names\n   * @return {Command} `this` command for chaining\n   */\n\n  arguments(names) {\n    names.split(/ +/).forEach((detail) => {\n      this.argument(detail);\n    });\n    return this;\n  };\n\n  /**\n   * Define argument syntax for command, adding a prepared argument.\n   *\n   * @param {Argument} argument\n   * @return {Command} `this` command for chaining\n   */\n  addArgument(argument) {\n    const previousArgument = this._args.slice(-1)[0];\n    if (previousArgument && previousArgument.variadic) {\n      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);\n    }\n    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {\n      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);\n    }\n    this._args.push(argument);\n    return this;\n  }\n\n  /**\n   * Override default decision whether to add implicit help command.\n   *\n   *    addHelpCommand() // force on\n   *    addHelpCommand(false); // force off\n   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details\n   *\n   * @return {Command} `this` command for chaining\n   */\n\n  addHelpCommand(enableOrNameAndArgs, description) {\n    if (enableOrNameAndArgs === false) {\n      this._addImplicitHelpCommand = false;\n    } else {\n      this._addImplicitHelpCommand = true;\n      if (typeof enableOrNameAndArgs === 'string') {\n        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];\n        this._helpCommandnameAndArgs = enableOrNameAndArgs;\n      }\n      this._helpCommandDescription = description || this._helpCommandDescription;\n    }\n    return this;\n  };\n\n  /**\n   * @return {boolean}\n   * @api private\n   */\n\n  _hasImplicitHelpCommand() {\n    if (this._addImplicitHelpCommand === undefined) {\n      return this.commands.length && !this._actionHandler && !this._findCommand('help');\n    }\n    return this._addImplicitHelpCommand;\n  };\n\n  /**\n   * Add hook for life cycle event.\n   *\n   * @param {string} event\n   * @param {Function} listener\n   * @return {Command} `this` command for chaining\n   */\n\n  hook(event, listener) {\n    const allowedValues = ['preAction', 'postAction'];\n    if (!allowedValues.includes(event)) {\n      throw new Error(`Unexpected value for event passed to hook : '${event}'.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    if (this._lifeCycleHooks[event]) {\n      this._lifeCycleHooks[event].push(listener);\n    } else {\n      this._lifeCycleHooks[event] = [listener];\n    }\n    return this;\n  }\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = (err) => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {\n          // Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n    return this;\n  };\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @api private\n   */\n\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message));\n      // Expecting this line is not reached.\n    }\n    process.exit(exitCode);\n  };\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * @example\n   * program\n   *   .command('serve')\n   *   .description('start service')\n   *   .action(function() {\n   *      // do work here\n   *   });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n\n  action(fn) {\n    const listener = (args) => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this._args.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n      actionArgs.push(this);\n\n      return fn.apply(this, actionArgs);\n    };\n    this._actionHandler = listener;\n    return this;\n  };\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n\n  createOption(flags, description) {\n    return new Option(flags, description);\n  };\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    const oname = option.name();\n    const name = option.attributeName();\n\n    let defaultValue = option.defaultValue;\n\n    // preassign default value for --no-*, [optional], <required>, or plain flag if boolean value\n    if (option.negate || option.optional || option.required || typeof defaultValue === 'boolean') {\n      // when --no-foo we make sure default is true, unless a --foo option is already defined\n      if (option.negate) {\n        const positiveLongFlag = option.long.replace(/^--no-/, '--');\n        defaultValue = this._findOption(positiveLongFlag) ? this.getOptionValue(name) : true;\n      }\n      // preassign only if we have a default\n      if (defaultValue !== undefined) {\n        this.setOptionValueWithSource(name, defaultValue, 'default');\n      }\n    }\n\n    // register the option\n    this.options.push(option);\n\n    // handler for cli and env supplied values\n    const handleOptionValue = (val, invalidValueMessage, valueSource) => {\n      // Note: using closure to access lots of lexical scoped variables.\n      const oldValue = this.getOptionValue(name);\n\n      // custom processing\n      if (val !== null && option.parseArg) {\n        try {\n          val = option.parseArg(val, oldValue === undefined ? defaultValue : oldValue);\n        } catch (err) {\n          if (err.code === 'commander.invalidArgument') {\n            const message = `${invalidValueMessage} ${err.message}`;\n            this._displayError(err.exitCode, err.code, message);\n          }\n          throw err;\n        }\n      } else if (val !== null && option.variadic) {\n        val = option._concatValue(val, oldValue);\n      }\n\n      // unassigned or boolean value\n      if (typeof oldValue === 'boolean' || typeof oldValue === 'undefined') {\n        // if no value, negate false, and we have a default, then use it!\n        if (val == null) {\n          this.setOptionValueWithSource(name, option.negate ? false : defaultValue || true, valueSource);\n        } else {\n          this.setOptionValueWithSource(name, val, valueSource);\n        }\n      } else if (val !== null) {\n        // reassign\n        this.setOptionValueWithSource(name, option.negate ? false : val, valueSource);\n      }\n    };\n\n    this.on('option:' + oname, (val) => {\n      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;\n      handleOptionValue(val, invalidValueMessage, 'cli');\n    });\n\n    if (option.envVar) {\n      this.on('optionEnv:' + oname, (val) => {\n        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;\n        handleOptionValue(val, invalidValueMessage, 'env');\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @api private\n   */\n  _optionEx(config, flags, description, fn, defaultValue) {\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n\n    return this.addOption(option);\n  }\n\n  /**\n   * Define option with `flags`, `description` and optional\n   * coercion `fn`.\n   *\n   * The `flags` string contains the short and/or long flags,\n   * separated by comma, a pipe or space. The following are all valid\n   * all will output this way when `--help` is used.\n   *\n   *     \"-p, --pepper\"\n   *     \"-p|--pepper\"\n   *     \"-p --pepper\"\n   *\n   * @example\n   * // simple boolean defaulting to undefined\n   * program.option('-p, --pepper', 'add pepper');\n   *\n   * program.pepper\n   * // => undefined\n   *\n   * --pepper\n   * program.pepper\n   * // => true\n   *\n   * // simple boolean defaulting to true (unless non-negated option is also defined)\n   * program.option('-C, --no-cheese', 'remove cheese');\n   *\n   * program.cheese\n   * // => true\n   *\n   * --no-cheese\n   * program.cheese\n   * // => false\n   *\n   * // required argument\n   * program.option('-C, --chdir <path>', 'change the working directory');\n   *\n   * --chdir /tmp\n   * program.chdir\n   * // => \"/tmp\"\n   *\n   * // optional argument\n   * program.option('-c, --cheese [type]', 'add cheese [marble]');\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  option(flags, description, fn, defaultValue) {\n    return this._optionEx({}, flags, description, fn, defaultValue);\n  };\n\n  /**\n  * Add a required option which must have a value after parsing. This usually means\n  * the option must be specified on the command line. (Otherwise the same as .option().)\n  *\n  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n  *\n  * @param {string} flags\n  * @param {string} [description]\n  * @param {Function|*} [fn] - custom option processing function or default value\n  * @param {*} [defaultValue]\n  * @return {Command} `this` command for chaining\n  */\n\n  requiredOption(flags, description, fn, defaultValue) {\n    return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);\n  };\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * @example\n   * // for `.option('-f,--flag [value]'):\n   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.\n   */\n  combineFlagAndOptionalValue(combine = true) {\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  };\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown\n   * for unknown options.\n   */\n  allowUnknownOption(allowUnknown = true) {\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  };\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown\n   * for excess arguments.\n   */\n  allowExcessArguments(allowExcess = true) {\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  };\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {Boolean} [positional=true]\n   */\n  enablePositionalOptions(positional = true) {\n    this._enablePositionalOptions = !!positional;\n    return this;\n  };\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {Boolean} [passThrough=true]\n   * for unknown options.\n   */\n  passThroughOptions(passThrough = true) {\n    this._passThroughOptions = !!passThrough;\n    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {\n      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');\n    }\n    return this;\n  };\n\n  /**\n    * Whether to store option values as properties on command object,\n    * or store separately (specify false). In both cases the option values can be accessed using .opts().\n    *\n    * @param {boolean} [storeAsProperties=true]\n    * @return {Command} `this` command for chaining\n    */\n\n  storeOptionsAsProperties(storeAsProperties = true) {\n    this._storeOptionsAsProperties = !!storeAsProperties;\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n    return this;\n  };\n\n  /**\n   * Retrieve option value.\n   *\n   * @param {string} key\n   * @return {Object} value\n   */\n\n  getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n    return this._optionValues[key];\n  };\n\n  /**\n   * Store option value.\n   *\n   * @param {string} key\n   * @param {Object} value\n   * @return {Command} `this` command for chaining\n   */\n\n  setOptionValue(key, value) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n    return this;\n  };\n\n  /**\n   * Store option value and where the value came from.\n    *\n    * @param {string} key\n    * @param {Object} value\n    * @param {string} source - expected values are default/config/env/cli\n    * @return {Command} `this` command for chaining\n    */\n\n  setOptionValueWithSource(key, value, source) {\n    this.setOptionValue(key, value);\n    this._optionValueSources[key] = source;\n    return this;\n  }\n\n  /**\n    * Get source of option value.\n    * Expected values are default | config | env | cli\n    *\n    * @param {string} key\n    * @return {string}\n    */\n\n  getOptionValueSource(key) {\n    return this._optionValueSources[key];\n  };\n\n  /**\n   * Get user arguments implied or explicit arguments.\n   * Side-effects: set _scriptPath if args included application, and use that to set implicit command name.\n   *\n   * @api private\n   */\n\n  _prepareUserArgs(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n    parseOptions = parseOptions || {};\n\n    // Default to using process.argv\n    if (argv === undefined) {\n      argv = process.argv;\n      // @ts-ignore: unknown property\n      if (process.versions && process.versions.electron) {\n        parseOptions.from = 'electron';\n      }\n    }\n    this.rawArgs = argv.slice();\n\n    // make it a little easier for callers by supporting various argv conventions\n    let userArgs;\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n      case 'electron':\n        // @ts-ignore: unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n        break;\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n      default:\n        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);\n    }\n    if (!this._scriptPath && require.main) {\n      this._scriptPath = require.main.filename;\n    }\n\n    // Guess name, used in usage in help.\n    this._name = this._name || (this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath)));\n\n    return userArgs;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * program.parse(process.argv);\n   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n\n  parse(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    this._parseCommand([], userArgs);\n\n    return this;\n  };\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * await program.parseAsync(process.argv);\n   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {Object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n\n  async parseAsync(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    await this._parseCommand([], userArgs);\n\n    return this;\n  };\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @api private\n   */\n\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n    this._checkForMissingMandatoryOptions();\n\n    // Want the entry script as the reference for command name and directory for searching for other files.\n    let scriptPath = this._scriptPath;\n    // Fallback in case not set, due to how Command created or called.\n    if (!scriptPath && require.main) {\n      scriptPath = require.main.filename;\n    }\n\n    let baseDir;\n    try {\n      const resolvedLink = fs.realpathSync(scriptPath);\n      baseDir = path.dirname(resolvedLink);\n    } catch (e) {\n      baseDir = '.'; // dummy, probably not going to find executable!\n    }\n\n    // name of the subcommand, like `pm-install`\n    let bin = path.basename(scriptPath, path.extname(scriptPath)) + '-' + subcommand._name;\n    if (subcommand._executableFile) {\n      bin = subcommand._executableFile;\n    }\n\n    const localBin = path.join(baseDir, bin);\n    if (fs.existsSync(localBin)) {\n      // prefer local `./<bin>` to bin in the $PATH\n      bin = localBin;\n    } else {\n      // Look for source files.\n      sourceExt.forEach((ext) => {\n        if (fs.existsSync(`${localBin}${ext}`)) {\n          bin = `${localBin}${ext}`;\n        }\n      });\n    }\n    launchWithNode = sourceExt.includes(path.extname(bin));\n\n    let proc;\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(bin);\n        // add executable arguments to spawn\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });\n      } else {\n        proc = childProcess.spawn(bin, args, { stdio: 'inherit' });\n      }\n    } else {\n      args.unshift(bin);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });\n    }\n\n    const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n    signals.forEach((signal) => {\n      // @ts-ignore\n      process.on(signal, () => {\n        if (proc.killed === false && proc.exitCode === null) {\n          proc.kill(signal);\n        }\n      });\n    });\n\n    // By default terminate process when spawned process terminates.\n    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!\n    const exitCallback = this._exitCallback;\n    if (!exitCallback) {\n      proc.on('close', process.exit.bind(process));\n    } else {\n      proc.on('close', () => {\n        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));\n      });\n    }\n    proc.on('error', (err) => {\n      // @ts-ignore\n      if (err.code === 'ENOENT') {\n        const executableMissing = `'${bin}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name`;\n        throw new Error(executableMissing);\n      // @ts-ignore\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${bin}' not executable`);\n      }\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    });\n\n    // Store the reference to the child process\n    this.runningCommand = proc;\n  };\n\n  /**\n   * @api private\n   */\n\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n    if (!subCommand) this.help({ error: true });\n\n    if (subCommand._executableHandler) {\n      this._executeSubCommand(subCommand, operands.concat(unknown));\n    } else {\n      return subCommand._parseCommand(operands, unknown);\n    }\n  };\n\n  /**\n   * Check this.args against expected this._args.\n   *\n   * @api private\n   */\n\n  _checkNumberOfArguments() {\n    // too few\n    this._args.forEach((arg, i) => {\n      if (arg.required && this.args[i] == null) {\n        this.missingArgument(arg.name());\n      }\n    });\n    // too many\n    if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {\n      return;\n    }\n    if (this.args.length > this._args.length) {\n      this._excessArguments(this.args);\n    }\n  };\n\n  /**\n   * Process this.args using this._args and save as this.processedArgs!\n   *\n   * @api private\n   */\n\n  _processArguments() {\n    const myParseArg = (argument, value, previous) => {\n      // Extra processing for nice error message on parsing failure.\n      let parsedValue = value;\n      if (value !== null && argument.parseArg) {\n        try {\n          parsedValue = argument.parseArg(value, previous);\n        } catch (err) {\n          if (err.code === 'commander.invalidArgument') {\n            const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;\n            this._displayError(err.exitCode, err.code, message);\n          }\n          throw err;\n        }\n      }\n      return parsedValue;\n    };\n\n    this._checkNumberOfArguments();\n\n    const processedArgs = [];\n    this._args.forEach((declaredArg, index) => {\n      let value = declaredArg.defaultValue;\n      if (declaredArg.variadic) {\n        // Collect together remaining arguments for passing together as an array.\n        if (index < this.args.length) {\n          value = this.args.slice(index);\n          if (declaredArg.parseArg) {\n            value = value.reduce((processed, v) => {\n              return myParseArg(declaredArg, v, processed);\n            }, declaredArg.defaultValue);\n          }\n        } else if (value === undefined) {\n          value = [];\n        }\n      } else if (index < this.args.length) {\n        value = this.args[index];\n        if (declaredArg.parseArg) {\n          value = myParseArg(declaredArg, value, declaredArg.defaultValue);\n        }\n      }\n      processedArgs[index] = value;\n    });\n    this.processedArgs = processedArgs;\n  }\n\n  /**\n   * Once we have a promise we chain, but call synchronously until then.\n   *\n   * @param {Promise|undefined} promise\n   * @param {Function} fn\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCall(promise, fn) {\n    // thenable\n    if (promise && promise.then && typeof promise.then === 'function') {\n      // already have a promise, chain callback\n      return promise.then(() => fn());\n    }\n    // callback might return a promise\n    return fn();\n  }\n\n  /**\n   *\n   * @param {Promise|undefined} promise\n   * @param {string} event\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCallHooks(promise, event) {\n    let result = promise;\n    const hooks = [];\n    getCommandAndParents(this)\n      .reverse()\n      .filter(cmd => cmd._lifeCycleHooks[event] !== undefined)\n      .forEach(hookedCommand => {\n        hookedCommand._lifeCycleHooks[event].forEach((callback) => {\n          hooks.push({ hookedCommand, callback });\n        });\n      });\n    if (event === 'postAction') {\n      hooks.reverse();\n    }\n\n    hooks.forEach((hookDetail) => {\n      result = this._chainOrCall(result, () => {\n        return hookDetail.callback(hookDetail.hookedCommand, this);\n      });\n    });\n    return result;\n  }\n\n  /**\n   * Process arguments in context of this command.\n   * Returns action result, in case it is a promise.\n   *\n   * @api private\n   */\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    }\n    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {\n      if (operands.length === 1) {\n        this.help();\n      }\n      return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);\n    }\n    if (this._defaultCommandName) {\n      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command\n      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);\n    }\n    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {\n      // probably missing subcommand and no handler, user needs help (and exit)\n      this.help({ error: true });\n    }\n\n    outputHelpIfRequested(this, parsed.unknown);\n    this._checkForMissingMandatoryOptions();\n\n    // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n    const checkForUnknownOptions = () => {\n      if (parsed.unknown.length > 0) {\n        this.unknownOption(parsed.unknown[0]);\n      }\n    };\n\n    const commandEvent = `command:${this.name()}`;\n    if (this._actionHandler) {\n      checkForUnknownOptions();\n      this._processArguments();\n\n      let actionResult;\n      actionResult = this._chainOrCallHooks(actionResult, 'preAction');\n      actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));\n      if (this.parent) this.parent.emit(commandEvent, operands, unknown); // legacy\n      actionResult = this._chainOrCallHooks(actionResult, 'postAction');\n      return actionResult;\n    }\n    if (this.parent && this.parent.listenerCount(commandEvent)) {\n      checkForUnknownOptions();\n      this._processArguments();\n      this.parent.emit(commandEvent, operands, unknown); // legacy\n    } else if (operands.length) {\n      if (this._findCommand('*')) { // legacy default command\n        return this._dispatchSubcommand('*', operands, unknown);\n      }\n      if (this.listenerCount('command:*')) {\n        // skip option check, emit event for possible misspelling suggestion\n        this.emit('command:*', operands, unknown);\n      } else if (this.commands.length) {\n        this.unknownCommand();\n      } else {\n        checkForUnknownOptions();\n        this._processArguments();\n      }\n    } else if (this.commands.length) {\n      checkForUnknownOptions();\n      // This command has subcommands and nothing hooked up at this level, so display help (and exit).\n      this.help({ error: true });\n    } else {\n      checkForUnknownOptions();\n      this._processArguments();\n      // fall through for caller to handle after calling .parse()\n    }\n  };\n\n  /**\n   * Find matching command.\n   *\n   * @api private\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));\n  };\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @api private\n   */\n\n  _findOption(arg) {\n    return this.options.find(option => option.is(arg));\n  };\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Lazy calling after checking for help flags from leaf subcommand.\n   *\n   * @api private\n   */\n\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    for (let cmd = this; cmd; cmd = cmd.parent) {\n      cmd.options.forEach((anOption) => {\n        if (anOption.mandatory && (cmd.getOptionValue(anOption.attributeName()) === undefined)) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    }\n  };\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *     argv => operands, unknown\n   *     --known kkk op => [op], []\n   *     op --known kkk => [op], []\n   *     sub --unknown uuu op => [sub], [--unknown uuu op]\n   *     sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {String[]} argv\n   * @return {{operands: String[], unknown: String[]}}\n   */\n\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n    const unknown = []; // first unknown option and remaining unknown args\n    let dest = operands;\n    const args = argv.slice();\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    }\n\n    // parse options\n    let activeVariadicOption = null;\n    while (args.length) {\n      const arg = args.shift();\n\n      // literal\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg);\n        // recognised option, call listener to assign value with possible custom processing\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null;\n            // historical behaviour is optional value is following arg unless an option\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n            this.emit(`option:${option.name()}`, value);\n          } else { // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      }\n\n      // Look for combo options following single dash, eat first one if known.\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n        if (option) {\n          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n          continue;\n        }\n      }\n\n      // Look for known long flag with value, like --foo=bar\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n        const option = this._findOption(arg.slice(0, index));\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      }\n\n      // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n      if (maybeOption(arg)) {\n        dest = unknown;\n      }\n\n      // If using positionalOptions, stop processing our options at subcommand.\n      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {\n          operands.push(arg);\n          if (args.length > 0) operands.push(...args);\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        }\n      }\n\n      // If using passThroughOptions, stop processing options at first command-argument.\n      if (this._passThroughOptions) {\n        dest.push(arg);\n        if (args.length > 0) dest.push(...args);\n        break;\n      }\n\n      // add arg\n      dest.push(arg);\n    }\n\n    return { operands, unknown };\n  };\n\n  /**\n   * Return an object containing options as key-value pairs\n   *\n   * @return {Object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] = key === this._versionOptionName ? this._version : this[key];\n      }\n      return result;\n    }\n\n    return this._optionValues;\n  };\n\n  /**\n   * Internal bottleneck for handling of parsing errors.\n   *\n   * @api private\n   */\n  _displayError(exitCode, code, message) {\n    this._outputConfiguration.outputError(`${message}\\n`, this._outputConfiguration.writeErr);\n    if (typeof this._showHelpAfterError === 'string') {\n      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\\n`);\n    } else if (this._showHelpAfterError) {\n      this._outputConfiguration.writeErr('\\n');\n      this.outputHelp({ error: true });\n    }\n    this._exit(exitCode, code, message);\n  }\n\n  /**\n   * Apply any option related environment variables, if option does\n   * not have a value from cli or client code.\n   *\n   * @api private\n   */\n  _parseOptionsEnv() {\n    this.options.forEach((option) => {\n      if (option.envVar && option.envVar in process.env) {\n        const optionKey = option.attributeName();\n        // Priority check. Do not overwrite cli or options from unknown source (client-code).\n        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {\n          if (option.required || option.optional) { // option can take a value\n            // keep very simple, optional always takes value\n            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);\n          } else { // boolean\n            // keep very simple, only care that envVar defined and not the value\n            this.emit(`optionEnv:${option.name()}`);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @api private\n   */\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n    this._displayError(1, 'commander.missingArgument', message);\n  };\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n    this._displayError(1, 'commander.optionMissingArgument', message);\n  };\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n    this._displayError(1, 'commander.missingMandatoryOptionValue', message);\n  };\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @api private\n   */\n\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    let suggestion = '';\n\n    if (flag.startsWith('--') && this._showSuggestionAfterError) {\n      // Looping to pick up the global options too\n      let candidateFlags = [];\n      let command = this;\n      do {\n        const moreFlags = command.createHelp().visibleOptions(command)\n          .filter(option => option.long)\n          .map(option => option.long);\n        candidateFlags = candidateFlags.concat(moreFlags);\n        command = command.parent;\n      } while (command && !command._enablePositionalOptions);\n      suggestion = suggestSimilar(flag, candidateFlags);\n    }\n\n    const message = `error: unknown option '${flag}'${suggestion}`;\n    this._displayError(1, 'commander.unknownOption', message);\n  };\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @api private\n   */\n\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n\n    const expected = this._args.length;\n    const s = (expected === 1) ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n    this._displayError(1, 'commander.excessArguments', message);\n  };\n\n  /**\n   * Unknown command.\n   *\n   * @api private\n   */\n\n  unknownCommand() {\n    const unknownName = this.args[0];\n    let suggestion = '';\n\n    if (this._showSuggestionAfterError) {\n      const candidateNames = [];\n      this.createHelp().visibleCommands(this).forEach((command) => {\n        candidateNames.push(command.name());\n        // just visible alias\n        if (command.alias()) candidateNames.push(command.alias());\n      });\n      suggestion = suggestSimilar(unknownName, candidateNames);\n    }\n\n    const message = `error: unknown command '${unknownName}'${suggestion}`;\n    this._displayError(1, 'commander.unknownCommand', message);\n  };\n\n  /**\n   * Set the program version to `str`.\n   *\n   * This method auto-registers the \"-V, --version\" flag\n   * which will print the version number when passed.\n   *\n   * You can optionally supply the  flags and description to override the defaults.\n   *\n   * @param {string} str\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {this | string} `this` command for chaining, or version string if no arguments\n   */\n\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName();\n    this.options.push(versionOption);\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  };\n\n  /**\n   * Set the description to `str`.\n   *\n   * @param {string} [str]\n   * @param {Object} [argsDescription]\n   * @return {string|Command}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined) return this._description;\n    this._description = str;\n    if (argsDescription) {\n      this._argsDescription = argsDescription;\n    }\n    return this;\n  };\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {string|Command}\n   */\n\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    /** @type {Command} */\n    let command = this;\n    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n\n    command._aliases.push(alias);\n    return this;\n  };\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {string[]|Command}\n   */\n\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n\n    aliases.forEach((alias) => this.alias(alias));\n    return this;\n  };\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {String|Command}\n   */\n\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this._args.map((arg) => {\n        return humanReadableArgName(arg);\n      });\n      return [].concat(\n        (this.options.length || this._hasHelpOption ? '[options]' : []),\n        (this.commands.length ? '[command]' : []),\n        (this._args.length ? args : [])\n      ).join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  };\n\n  /**\n   * Get or set the name of the command\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  };\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n    if (helper.helpWidth === undefined) {\n      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();\n    }\n    return helper.formatHelp(this, helper);\n  };\n\n  /**\n   * @api private\n   */\n\n  _getHelpContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const context = { error: !!contextOptions.error };\n    let write;\n    if (context.error) {\n      write = (arg) => this._outputConfiguration.writeErr(arg);\n    } else {\n      write = (arg) => this._outputConfiguration.writeOut(arg);\n    }\n    context.write = contextOptions.write || write;\n    context.command = this;\n    return context;\n  }\n\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n    const context = this._getHelpContext(contextOptions);\n\n    getCommandAndParents(this).reverse().forEach(command => command.emit('beforeAllHelp', context));\n    this.emit('beforeHelp', context);\n\n    let helpInformation = this.helpInformation(context);\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n    context.write(helpInformation);\n\n    this.emit(this._helpLongFlag); // deprecated\n    this.emit('afterHelp', context);\n    getCommandAndParents(this).forEach(command => command.emit('afterAllHelp', context));\n  };\n\n  /**\n   * You can pass in flags and a description to override the help\n   * flags and help description for your command. Pass in false to\n   * disable the built-in help option.\n   *\n   * @param {string | boolean} [flags]\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n\n  helpOption(flags, description) {\n    if (typeof flags === 'boolean') {\n      this._hasHelpOption = flags;\n      return this;\n    }\n    this._helpFlags = flags || this._helpFlags;\n    this._helpDescription = description || this._helpDescription;\n\n    const helpFlags = splitOptionFlags(this._helpFlags);\n    this._helpShortFlag = helpFlags.shortFlag;\n    this._helpLongFlag = helpFlags.longFlag;\n\n    return this;\n  };\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = process.exitCode || 0;\n    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {\n      exitCode = 1;\n    }\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  };\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {string | Function} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, (context) => {\n      let helpStr;\n      if (typeof text === 'function') {\n        helpStr = text({ error: context.error, command: context.command });\n      } else {\n        helpStr = text;\n      }\n      // Ignore falsy value when nothing to output.\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n};\n\n/**\n * Output help information if help flags specified\n *\n * @param {Command} cmd - command to output help for\n * @param {Array} args - array of options to search for help flags\n * @api private\n */\n\nfunction outputHelpIfRequested(cmd, args) {\n  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);\n  if (helpOption) {\n    cmd.outputHelp();\n    // (Do not have all displayed text available so only passing placeholder.)\n    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n  }\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @api private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n      debugOption = match[1];\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n    return arg;\n  });\n}\n\n/**\n * @param {Command} startCommand\n * @returns {Command[]}\n * @api private\n */\n\nfunction getCommandAndParents(startCommand) {\n  const result = [];\n  for (let command = startCommand; command; command = command.parent) {\n    result.push(command);\n  }\n  return result;\n}\n\nexports.Command = Command;\n","// @ts-check\n\n/**\n * CommanderError class\n * @class\n */\nclass CommanderError extends Error {\n  /**\n   * Constructs the CommanderError class\n   * @param {number} exitCode suggested exit code which could be used with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @constructor\n   */\n  constructor(exitCode, code, message) {\n    super(message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.exitCode = exitCode;\n    this.nestedError = undefined;\n  }\n}\n\n/**\n * InvalidArgumentError class\n * @class\n */\nclass InvalidArgumentError extends CommanderError {\n  /**\n   * Constructs the InvalidArgumentError class\n   * @param {string} [message] explanation of why argument is invalid\n   * @constructor\n   */\n  constructor(message) {\n    super(1, 'commander.invalidArgument', message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n  }\n}\n\nexports.CommanderError = CommanderError;\nexports.InvalidArgumentError = InvalidArgumentError;\n","const { humanReadableArgName } = require('./argument.js');\n\n/**\n * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option\n */\n\n// @ts-check\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n    if (cmd._hasImplicitHelpCommand()) {\n      // Create a command matching the implicit help command.\n      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);\n      const helpCommand = cmd.createCommand(helpName)\n        .helpOption(false);\n      helpCommand.description(cmd._helpCommandDescription);\n      if (helpArgs) helpCommand.arguments(helpArgs);\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        // @ts-ignore: overloaded return type\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter((option) => !option.hidden);\n    // Implicit help\n    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);\n    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpOption;\n      if (!showShortHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);\n      } else if (!showLongHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);\n      } else {\n        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);\n      }\n      visibleOptions.push(helpOption);\n    }\n    if (this.sortOptions) {\n      const getSortKey = (option) => {\n        // WYSIWYG for order displayed in help with short before long, no special handling for negated.\n        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n      };\n      visibleOptions.sort((a, b) => {\n        return getSortKey(a).localeCompare(getSortKey(b));\n      });\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the arguments if any have a description.\n   *\n   * @param {Command} cmd\n   * @returns {Argument[]}\n   */\n\n  visibleArguments(cmd) {\n    // Side effect! Apply the legacy descriptions before the arguments are displayed.\n    if (cmd._argsDescription) {\n      cmd._args.forEach(argument => {\n        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';\n      });\n    }\n\n    // If there are any arguments with a description then return all the arguments.\n    if (cmd._args.find(argument => argument.description)) {\n      return cmd._args;\n    };\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');\n    return cmd._name +\n      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +\n      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option\n      (args ? ' ' + args : '');\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the argument term to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @returns {string}\n   */\n\n  argumentTerm(argument) {\n    return argument.name();\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  };\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  };\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, helper.argumentTerm(argument).length);\n    }, 0);\n  };\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let parentCmdNames = '';\n    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {\n      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;\n    }\n    return parentCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the command description to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    const extraInfo = [];\n    // Some of these do not make sense for negated boolean and suppress for backwards compatibility.\n\n    if (option.argChoices && !option.negate) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (option.defaultValue !== undefined && !option.negate) {\n      extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n    }\n    if (option.envVar !== undefined) {\n      extraInfo.push(`env: ${option.envVar}`);\n    }\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n\n    return option.description;\n  };\n\n  /**\n   * Get the argument description to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @return {string}\n   */\n\n  argumentDescription(argument) {\n    const extraInfo = [];\n    if (argument.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (argument.defaultValue !== undefined) {\n      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);\n    }\n    if (extraInfo.length > 0) {\n      const extraDescripton = `(${extraInfo.join(', ')})`;\n      if (argument.description) {\n        return `${argument.description} ${extraDescripton}`;\n      }\n      return extraDescripton;\n    }\n    return argument.description;\n  }\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n      return term;\n    };\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    }\n\n    // Usage\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([commandDescription, '']);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map((argument) => {\n      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));\n    });\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    }\n\n    // Options\n    const optionList = helper.visibleOptions(cmd).map((option) => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    }\n\n    // Commands\n    const commandList = helper.visibleCommands(cmd).map((cmd) => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(\n      helper.longestOptionTermLength(cmd, helper),\n      helper.longestSubcommandTermLength(cmd, helper),\n      helper.longestArgumentTermLength(cmd, helper)\n    );\n  };\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n\n  wrap(str, width, indent, minColumnWidth = 40) {\n    // Detect manually wrapped and indented strings by searching for line breaks\n    // followed by multiple spaces/tabs.\n    if (str.match(/[\\n]\\s+/)) return str;\n    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n\n    const leadingStr = str.substr(0, indent);\n    const columnText = str.substr(indent);\n\n    const indentString = ' '.repeat(indent);\n    const regex = new RegExp('.{1,' + (columnWidth - 1) + '}([\\\\s\\u200B]|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]|$)', 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line.slice(-1) === '\\n') {\n        line = line.slice(0, line.length - 1);\n      }\n      return ((i > 0) ? indentString : '') + line.trimRight();\n    }).join('\\n');\n  }\n}\n\nexports.Help = Help;\n","const { InvalidArgumentError } = require('./error.js');\n\n// @ts-check\n\nclass Option {\n  /**\n   * Initialize a new `Option` with the given `flags` and `description`.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   */\n\n  constructor(flags, description) {\n    this.flags = flags;\n    this.description = description || '';\n\n    this.required = flags.includes('<'); // A value must be supplied when the option is specified.\n    this.optional = flags.includes('['); // A value is optional when the option is specified.\n    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument\n    this.variadic = /\\w\\.\\.\\.[>\\]]$/.test(flags); // The option can take multiple values.\n    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n    const optionFlags = splitOptionFlags(flags);\n    this.short = optionFlags.shortFlag;\n    this.long = optionFlags.longFlag;\n    this.negate = false;\n    if (this.long) {\n      this.negate = this.long.startsWith('--no-');\n    }\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.envVar = undefined;\n    this.parseArg = undefined;\n    this.hidden = false;\n    this.argChoices = undefined;\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {any} value\n   * @param {string} [description]\n   * @return {Option}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  };\n\n  /**\n   * Set environment variable to check for option value.\n   * Priority order of option values is default < env < cli\n   *\n   * @param {string} name\n   * @return {Option}\n   */\n\n  env(name) {\n    this.envVar = name;\n    return this;\n  };\n\n  /**\n   * Set the custom handler for processing CLI option arguments into option values.\n   *\n   * @param {Function} [fn]\n   * @return {Option}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  };\n\n  /**\n   * Whether the option is mandatory and must have a value after parsing.\n   *\n   * @param {boolean} [mandatory=true]\n   * @return {Option}\n   */\n\n  makeOptionMandatory(mandatory = true) {\n    this.mandatory = !!mandatory;\n    return this;\n  };\n\n  /**\n   * Hide option in help.\n   *\n   * @param {boolean} [hide=true]\n   * @return {Option}\n   */\n\n  hideHelp(hide = true) {\n    this.hidden = !!hide;\n    return this;\n  };\n\n  /**\n   * @api private\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Option}\n   */\n\n  choices(values) {\n    this.argChoices = values;\n    this.parseArg = (arg, previous) => {\n      if (!values.includes(arg)) {\n        throw new InvalidArgumentError(`Allowed choices are ${values.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  };\n\n  /**\n   * Return option name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    if (this.long) {\n      return this.long.replace(/^--/, '');\n    }\n    return this.short.replace(/^-/, '');\n  };\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as a object attribute key.\n   *\n   * @return {string}\n   * @api private\n   */\n\n  attributeName() {\n    return camelcase(this.name().replace(/^no-/, ''));\n  };\n\n  /**\n   * Check if `arg` matches the short or long flag.\n   *\n   * @param {string} arg\n   * @return {boolean}\n   * @api private\n   */\n\n  is(arg) {\n    return this.short === arg || this.long === arg;\n  };\n}\n\n/**\n * Convert string from kebab-case to camelCase.\n *\n * @param {string} str\n * @return {string}\n * @api private\n */\n\nfunction camelcase(str) {\n  return str.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Split the short and long flag out of something like '-m,--mixed <value>'\n *\n * @api private\n */\n\nfunction splitOptionFlags(flags) {\n  let shortFlag;\n  let longFlag;\n  // Use original very loose parsing to maintain backwards compatibility for now,\n  // which allowed for example unintended `-sw, --short-word` [sic].\n  const flagParts = flags.split(/[ |,]+/);\n  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();\n  longFlag = flagParts.shift();\n  // Add support for lone short flag without significantly changing parsing!\n  if (!shortFlag && /^-[^-]$/.test(longFlag)) {\n    shortFlag = longFlag;\n    longFlag = undefined;\n  }\n  return { shortFlag, longFlag };\n}\n\nexports.Option = Option;\nexports.splitOptionFlags = splitOptionFlags;\n","const maxDistance = 3;\n\nfunction editDistance(a, b) {\n  // https://en.wikipedia.org/wiki/DamerauLevenshtein_distance\n  // Calculating optimal string alignment distance, no substring is edited more than once.\n  // (Simple implementation.)\n\n  // Quick early exit, return worst case.\n  if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);\n\n  // distance between prefix substrings of a and b\n  const d = [];\n\n  // pure deletions turn a into empty string\n  for (let i = 0; i <= a.length; i++) {\n    d[i] = [i];\n  }\n  // pure insertions turn empty string into b\n  for (let j = 0; j <= b.length; j++) {\n    d[0][j] = j;\n  }\n\n  // fill matrix\n  for (let j = 1; j <= b.length; j++) {\n    for (let i = 1; i <= a.length; i++) {\n      let cost = 1;\n      if (a[i - 1] === b[j - 1]) {\n        cost = 0;\n      } else {\n        cost = 1;\n      }\n      d[i][j] = Math.min(\n        d[i - 1][j] + 1, // deletion\n        d[i][j - 1] + 1, // insertion\n        d[i - 1][j - 1] + cost // substitution\n      );\n      // transposition\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);\n      }\n    }\n  }\n\n  return d[a.length][b.length];\n}\n\n/**\n * Find close matches, restricted to same number of edits.\n *\n * @param {string} word\n * @param {string[]} candidates\n * @returns {string}\n */\n\nfunction suggestSimilar(word, candidates) {\n  if (!candidates || candidates.length === 0) return '';\n  // remove possible duplicates\n  candidates = Array.from(new Set(candidates));\n\n  const searchingOptions = word.startsWith('--');\n  if (searchingOptions) {\n    word = word.slice(2);\n    candidates = candidates.map(candidate => candidate.slice(2));\n  }\n\n  let similar = [];\n  let bestDistance = maxDistance;\n  const minSimilarity = 0.4;\n  candidates.forEach((candidate) => {\n    if (candidate.length <= 1) return; // no one character guesses\n\n    const distance = editDistance(word, candidate);\n    const length = Math.max(word.length, candidate.length);\n    const similarity = (length - distance) / length;\n    if (similarity > minSimilarity) {\n      if (distance < bestDistance) {\n        // better edit distance, throw away previous worse matches\n        bestDistance = distance;\n        similar = [candidate];\n      } else if (distance === bestDistance) {\n        similar.push(candidate);\n      }\n    }\n  });\n\n  similar.sort((a, b) => a.localeCompare(b));\n  if (searchingOptions) {\n    similar = similar.map(candidate => `--${candidate}`);\n  }\n\n  if (similar.length > 1) {\n    return `\\n(Did you mean one of ${similar.join(', ')}?)`;\n  }\n  if (similar.length === 1) {\n    return `\\n(Did you mean ${similar[0]}?)`;\n  }\n  return '';\n}\n\nexports.suggestSimilar = suggestSimilar;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"]}